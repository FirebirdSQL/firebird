/*
 *  PROGRAM:    Dynamic SQL runtime support
 *  MODULE:     metd.epp
 *  DESCRIPTION:    Meta-data interface
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 * 2001.11.28 Claudio Valderrama: load not only udfs but udf arguments;
 *   handle possible collisions with udf redefinitions (drop->declare).
 *   This closes SF Bug# 409769.
 * 2001.12.06 Claudio Valderrama: METD_get_charset_bpc() was added to
 *    get only the bytes per char of a field, given its charset id.
 *   This request is not cached.
 * 2001.02.23 Claudio Valderrama: Fix SF Bug #228135 with views spoiling
 *    NULLs in outer joins.
 * 2004.01.16 Vlad Horsun: make METD_get_col_default and
 *   METD_get_domain_default return actual length of default BLR
 * 2004.01.16 Vlad Horsun: added support for default parameters
 */

#include "firebird.h"
#include <string.h>
#include "../dsql/dsql.h"
#include "ibase.h"
#include "../jrd/align.h"
#include "../jrd/intl.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/met.h"
#include "../dsql/ExprNodes.h"
#include "../dsql/ddl_proto.h"
#include "../dsql/metd_proto.h"
#include "../dsql/make_proto.h"
#include "../dsql/errd_proto.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/exe_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/met_proto.h"
#include "../yvalve/why_proto.h"
#include "../common/utils_proto.h"
#include "../common/classes/init.h"

using namespace Jrd;
using namespace Firebird;

// NOTE: The static definition of DB and gds_trans by gpre will not
// be used by the meta data routines.  Each of those routines has
// its own local definition of these variables.

DATABASE DB = STATIC "yachts.lnk";

static void convert_dtype(TypeClause*, SSHORT);

namespace
{
	inline void validateTransaction(const jrd_tra* transaction)
	{
		if (!transaction || !transaction->checkHandle())
		{
			ERR_post(Arg::Gds(isc_bad_trans_handle));
		}
	}
}


void METD_drop_charset(jrd_tra* transaction, const MetaName& metaName)
{
/**************************************
 *
 *  M E T D _ d r o p _ c h a r s e t
 *
 **************************************
 *
 * Functional description
 *  Drop a character set from our metadata, and the next caller who wants it will
 *  look up the new version.
 *  Dropping will be achieved by marking the character set
 *  as dropped.  Anyone with current access can continue
 *  accessing it.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	dsql_dbb* dbb = transaction->getDsqlAttachment();
	dsql_intlsym* charSet;

	if (dbb->dbb_charsets.get(metaName, charSet))
	{
		MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_charset, metaName);
		charSet->intlsym_flags |= INTLSYM_dropped;
		dbb->dbb_charsets.remove(metaName);
		dbb->dbb_charsets_by_id.remove(charSet->intlsym_charset_id);
	}
}


void METD_drop_collation(jrd_tra* transaction, const MetaName& name)
{
/**************************************
 *
 *  M E T D _ d r o p _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Drop a collation from our metadata, and
 *  the next caller who wants it will
 *  look up the new version.
 *
 *  Dropping will be achieved by marking the collation
 *  as dropped.  Anyone with current access can continue
 *  accessing it.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	dsql_dbb* dbb = transaction->getDsqlAttachment();

	dsql_intlsym* collation;

	if (dbb->dbb_collations.get(name, collation))
	{
		MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_collation, name);
		collation->intlsym_flags |= INTLSYM_dropped;
		dbb->dbb_collations.remove(name);
	}
}


dsql_intlsym* METD_get_collation(jrd_tra* transaction, const MetaName& name, CSetId charset_id)
{
/**************************************
 *
 *  M E T D _ g e t _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return NULL.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	// Start by seeing if symbol is already defined

	dsql_intlsym* symbol;
	if (dbb->dbb_collations.get(name, symbol) && !(symbol->intlsym_flags & INTLSYM_dropped) &&
		symbol->intlsym_charset_id == charset_id)
	{
		if (MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_collation, name))
			symbol->intlsym_flags |= INTLSYM_dropped;
		else
			return symbol;
	}

	// Now see if it is in the database

	symbol = NULL;

	AutoCacheRequest handle(tdbb, irq_collation, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
	X IN RDB$COLLATIONS
		CROSS Y IN RDB$CHARACTER_SETS OVER RDB$CHARACTER_SET_ID
		WITH X.RDB$COLLATION_NAME EQ name.c_str() AND
			 X.RDB$CHARACTER_SET_ID EQ charset_id
	{
		symbol = FB_NEW_POOL(dbb->dbb_pool) dsql_intlsym(dbb->dbb_pool);
		symbol->intlsym_name = name;
		symbol->intlsym_flags = 0;
		symbol->intlsym_charset_id = CSetId(X.RDB$CHARACTER_SET_ID);
		symbol->intlsym_collate_id = CollId(X.RDB$COLLATION_ID);
		symbol->intlsym_ttype =
			TTypeId(symbol->intlsym_charset_id, symbol->intlsym_collate_id);
		symbol->intlsym_bytes_per_char =
			(Y.RDB$BYTES_PER_CHARACTER.NULL) ? 1 : (Y.RDB$BYTES_PER_CHARACTER);
	}
	END_FOR

	if (!symbol)
		return NULL;

	dbb->dbb_collations.put(name, symbol);
	MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_collation, name);

	return symbol;
}


dsql_intlsym* METD_get_charset(jrd_tra* transaction, USHORT length, const char* name) // UTF-8
{
/**************************************
 *
 *  M E T D _ g e t _ c h a r s e t
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return NULL.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();
	MetaName metaName(name, length);

	// Start by seeing if symbol is already defined

	dsql_intlsym* symbol;
	if (dbb->dbb_charsets.get(metaName, symbol) && !(symbol->intlsym_flags & INTLSYM_dropped))
	{
		if (MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_charset, metaName))
			symbol->intlsym_flags |= INTLSYM_dropped;
		else
			return symbol;
	}

	// Now see if it is in the database

	symbol = NULL;

	AutoCacheRequest handle(tdbb, irq_charset, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
	X IN RDB$COLLATIONS
		CROSS Y IN RDB$CHARACTER_SETS OVER RDB$CHARACTER_SET_ID
		CROSS Z IN RDB$TYPES
		WITH Z.RDB$TYPE EQ Y.RDB$CHARACTER_SET_ID
		AND Z.RDB$TYPE_NAME EQ name
		AND Z.RDB$FIELD_NAME EQ "RDB$CHARACTER_SET_NAME"
		AND Y.RDB$DEFAULT_COLLATE_NAME EQ X.RDB$COLLATION_NAME;
	{
		symbol = FB_NEW_POOL(dbb->dbb_pool) dsql_intlsym(dbb->dbb_pool);
		symbol->intlsym_name = metaName;
		symbol->intlsym_flags = 0;
		symbol->intlsym_charset_id = CSetId(X.RDB$CHARACTER_SET_ID);
		symbol->intlsym_collate_id = CollId(X.RDB$COLLATION_ID);
		symbol->intlsym_ttype =
			TTypeId(CSetId(symbol->intlsym_charset_id), CollId(symbol->intlsym_collate_id));
		symbol->intlsym_bytes_per_char =
			(Y.RDB$BYTES_PER_CHARACTER.NULL) ? 1 : (Y.RDB$BYTES_PER_CHARACTER);
	}
	END_FOR

	if (!symbol)
		return NULL;

	dbb->dbb_charsets.put(metaName, symbol);
	dbb->dbb_charsets_by_id.put(symbol->intlsym_charset_id, symbol);
	MetadataCache::dsql_cache_use(tdbb, SYM_intlsym_charset, metaName);

	return symbol;
}


USHORT METD_get_charset_bpc(jrd_tra* transaction, CSetId charset_id)
{
/**************************************
 *
 *  M E T D _ g e t _ c h a r s e t _ b p c
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return NULL.
 *  Go directly to system tables & return only the
 *  number of bytes per character. Lookup by
 *  charset' id, not by name.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	dsql_dbb* dbb = transaction->getDsqlAttachment();

	if (charset_id == CS_dynamic)
		charset_id = tdbb->getCharSet();

	dsql_intlsym* symbol = NULL;
	if (!dbb->dbb_charsets_by_id.get(charset_id, symbol))
	{
		const MetaName cs_name = METD_get_charset_name(transaction, charset_id);
		symbol = METD_get_charset(transaction, cs_name.length(), cs_name.c_str());
	}

	fb_assert(symbol);

	return symbol ? symbol->intlsym_bytes_per_char : 0;
}


MetaName METD_get_charset_name(jrd_tra* transaction, CSetId charset_id)
{
/**************************************
 *
 *  M E T D _ g e t _ c h a r s e t _ n a m e
 *
 **************************************
 *
 * Functional description
 *  Look up an international text type object.
 *  If it doesn't exist, return empty string.
 *  Go directly to system tables & return only the
 *  name.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();

    if (charset_id == CS_dynamic)
		charset_id = tdbb->getCharSet();

	dsql_intlsym* sym = NULL;
	if (dbb->dbb_charsets_by_id.get(charset_id, sym))
		return sym->intlsym_name;

	MetaName name;

	AutoCacheRequest handle(tdbb, irq_cs_name, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		Y IN RDB$CHARACTER_SETS
		WITH Y.RDB$CHARACTER_SET_ID EQ charset_id
	{
		name = Y.RDB$CHARACTER_SET_NAME;
	}
	END_FOR

	// put new charset into hash table if needed
	METD_get_charset(transaction, name.length(), name.c_str());

	return name;
}


MetaName METD_get_default_charset(jrd_tra* transaction)
{
/**************************************
 *
 *  M E T D _ g e t _ d e f a u l t _ c h a r s e t
 *
 **************************************
 *
 * Functional description
 *  Find the default character set for a database
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_dbb* dbb = transaction->getDsqlAttachment();
	if (dbb->dbb_no_charset)
		return NULL;

	if (dbb->dbb_dfl_charset.hasData())
		return dbb->dbb_dfl_charset;

	// Now see if it is in the database

	AutoCacheRequest handle(tdbb, irq_default_cs, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		FIRST 1 DBB IN RDB$DATABASE
		WITH DBB.RDB$CHARACTER_SET_NAME NOT MISSING;
	{
		// Terminate ASCIIZ string on first trailing blank
		fb_utils::exact_name(DBB.RDB$CHARACTER_SET_NAME);
		dbb->dbb_dfl_charset = DBB.RDB$CHARACTER_SET_NAME;
	}
	END_FOR

	if (dbb->dbb_dfl_charset.isEmpty())
		dbb->dbb_no_charset = true;

	return dbb->dbb_dfl_charset;
}


bool METD_get_domain(jrd_tra* transaction, TypeClause* field, const MetaName& name) // UTF-8
{
/**************************************
 *
 *  M E T D _ g e t _ d o m a i n
 *
 **************************************
 *
 * Functional description
 *  Fetch domain information for field defined as 'name'
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	bool found = false;

	AutoCacheRequest handle(tdbb, irq_domain, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		FLX IN RDB$FIELDS WITH FLX.RDB$FIELD_NAME EQ name.c_str()
	{
		found = true;
		field->length = FLX.RDB$FIELD_LENGTH;
		field->scale = FLX.RDB$FIELD_SCALE;
		field->subType = FLX.RDB$FIELD_SUB_TYPE;
		field->dimensions = FLX.RDB$DIMENSIONS.NULL ? 0 : FLX.RDB$DIMENSIONS;

		field->charSetId = std::nullopt;
		if (!FLX.RDB$CHARACTER_SET_ID.NULL)
			field->charSetId = CSetId(FLX.RDB$CHARACTER_SET_ID);
		field->collationId = CollId(0);
		if (!FLX.RDB$COLLATION_ID.NULL)
			field->collationId = CollId(FLX.RDB$COLLATION_ID);
		field->charLength = 0;
		if (!FLX.RDB$CHARACTER_LENGTH.NULL)
			field->charLength = FLX.RDB$CHARACTER_LENGTH;

		if (!FLX.RDB$COMPUTED_BLR.NULL)
			field->flags |= FLD_computed;

		if (FLX.RDB$NULL_FLAG.NULL || !FLX.RDB$NULL_FLAG)
			field->flags |= FLD_nullable;

		if (FLX.RDB$SYSTEM_FLAG == 1)
			field->flags |= FLD_system;

		convert_dtype(field, FLX.RDB$FIELD_TYPE);

		if (FLX.RDB$FIELD_TYPE == blr_blob) {
			field->segLength = FLX.RDB$SEGMENT_LENGTH;
		}
	}
	END_FOR

	return found;
}


dsql_udf* METD_get_function(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ f u n c t i o n
 *
 **************************************
 *
 * Functional description
 *  Look up a user defined function.  If it doesn't exist,
 *  return NULL.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	validateTransaction(transaction);

	dsql_udf* userFunc = NULL;

	QualifiedName metaName(name);

	bool maybeUnqualified = dsqlScratch->package.hasData() && metaName.package.isEmpty();
	if (maybeUnqualified)
		metaName.package = dsqlScratch->package;

	// Start by seeing if symbol is already defined

	if (dsqlScratch->functions.get(metaName, userFunc))
	{
		if (userFunc->udf_private && metaName.package != dsqlScratch->package)
		{
			status_exception::raise(Arg::Gds(isc_private_function) <<
				Arg::Str(metaName.identifier) << Arg::Str(metaName.package));
		}

		return userFunc;
	}

	// now see if it is in the metadata cache

	USHORT return_arg = 0;

	for (;;)
	{
		auto* jfunc = MetadataCache::lookup_function(tdbb, metaName, CacheFlag::AUTOCREATE);
		if (jfunc)
		{
			userFunc = FB_NEW_POOL(dsqlScratch->getPool()) dsql_udf(dsqlScratch->getPool(), jfunc);

			if (userFunc->udf_private && metaName.package != dsqlScratch->package)
			{
				status_exception::raise(Arg::Gds(isc_private_procedure) <<
					Arg::Str(metaName.identifier) << Arg::Str(metaName.package));
			}

			dsqlScratch->functions.put(userFunc->udf_name, userFunc);
			return userFunc;
		}

		if (maybeUnqualified)
		{
			maybeUnqualified = false;
			metaName.package = "";
		}
		else
			break;
	}

	return nullptr;
}


void METD_get_primary_key(jrd_tra* transaction, const MetaName& relationName,
	Array<NestConst<FieldNode> >& fields)
{
/**************************************
 *
 *  M E T D _ g e t _ p r i m a r y _ k e y
 *
 **************************************
 *
 * Functional description
 *  Lookup the fields for the primary key
 *  index on a relation, returning a list
 *  node of the fields.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	MemoryPool& pool = *tdbb->getDefaultPool();

	validateTransaction(transaction);

	AutoCacheRequest handle(tdbb, irq_primary_key, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$INDICES CROSS
		Y IN RDB$INDEX_SEGMENTS
		OVER RDB$INDEX_NAME CROSS
		Z IN RDB$RELATION_CONSTRAINTS
		OVER RDB$INDEX_NAME
		WITH Z.RDB$RELATION_NAME EQ relationName.c_str()
		AND Z.RDB$CONSTRAINT_TYPE EQ "PRIMARY KEY"
		SORTED BY Y.RDB$FIELD_POSITION
	{
		FieldNode* fieldNode = FB_NEW_POOL(pool) FieldNode(pool);
		fieldNode->dsqlName = Y.RDB$FIELD_NAME;
		fields.add(fieldNode);
	}
	END_FOR
}


dsql_prc* METD_get_procedure(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const QualifiedName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *  Look up a procedure.  If it doesn't exist, return NULL.
 *  If it does, fetch field information as well.
 *  If it is marked dropped, try to read from system tables
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();
	validateTransaction(transaction);

	QualifiedName metaName(name);

	bool maybeUnqualified = dsqlScratch->package.hasData() && metaName.package.isEmpty();
	if (maybeUnqualified)
		metaName.package = dsqlScratch->package;

	// Start by seeing if symbol is already defined

	dsql_prc* procedure = NULL;
	if (dsqlScratch->procedures.get(metaName, procedure))
	{
		if (procedure->prc_private && metaName.package != dsqlScratch->package)
		{
			status_exception::raise(Arg::Gds(isc_private_procedure) <<
				Arg::Str(metaName.identifier) << Arg::Str(metaName.package));
		}

		return procedure;
	}

	// now see if it is in the metadata cache

	for (;;)
	{
		auto* jproc = MetadataCache::lookup_procedure(tdbb, metaName, CacheFlag::AUTOCREATE);
		if (jproc)
		{
			procedure = FB_NEW_POOL(dsqlScratch->getPool()) dsql_prc(dsqlScratch->getPool(), jproc);

			if (procedure->prc_private && metaName.package != dsqlScratch->package)
			{
				status_exception::raise(Arg::Gds(isc_private_procedure) <<
					Arg::Str(metaName.identifier) << Arg::Str(metaName.package));
			}

			dsqlScratch->procedures.put(procedure->prc_name, procedure);
			return procedure;
		}

		if (maybeUnqualified)
		{
			maybeUnqualified = false;
			metaName.package = "";
		}
		else
			break;
	}

	return nullptr;
}


dsql_rel* METD_get_relation(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const MetaName& name)
{
/**************************************
 *
 *  M E T D _ g e t _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Look up a relation.  If it doesn't exist, return NULL.
 *  If it does, fetch field information as well.
 *
 **************************************/

	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	// See if the relation is the one currently being defined in this statement

	auto* relation = dsqlScratch->relation;
	if (relation != NULL && relation->rel_name == name)
	{
		return relation;
	}

	if (dsqlScratch->rels.get(name, relation))
	{
		return relation;
	}

	// now see if it is in the metadata cache

	auto* jrel = MetadataCache::lookup_relation(tdbb, name, CacheFlag::AUTOCREATE);
	if (!jrel)
		return nullptr;

	relation = FB_NEW_POOL(dsqlScratch->getPool()) dsql_rel(dsqlScratch->getPool(), jrel);
	dsqlScratch->rels.put(relation->rel_name, relation);

	return relation;
}


bool METD_get_type(jrd_tra* transaction, const MetaName& name, const char* field, SSHORT* value)
{
/**************************************
 *
 *  M E T D _ g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *  Look up a symbolic name in RDB$TYPES
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	bool found = false;

	AutoCacheRequest handle(tdbb, irq_type, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$TYPES WITH
		X.RDB$FIELD_NAME EQ field AND X.RDB$TYPE_NAME EQ name.c_str();
	{
		found = true;
		*value = X.RDB$TYPE;
	}
	END_FOR

	return found;
}


dsql_rel* METD_get_view_base(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const char* view_name, MetaNamePairMap& fields)
{
/**************************************
 *
 *  M E T D _ g e t _ v i e w _ b a s e
 *
 **************************************
 *
 * Functional description
 *  Return the base table of a view or NULL if there
 *  is more than one.
 *  If there is only one base, put in fields a map of
 *  top view field name / bottom base field name.
 *  Ignores the field in the case of a base field name
 *  appearing more than one time in a level.
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	dsql_rel* relation = NULL;

	bool first = true;
	bool cont = true;
	MetaNamePairMap previousAux;

	fields.clear();

	while (cont)
	{
		AutoCacheRequest handle1(tdbb, irq_view_base, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE handle1 TRANSACTION_HANDLE transaction)
			X IN RDB$VIEW_RELATIONS
			WITH X.RDB$VIEW_NAME EQ view_name
		{
			// return NULL if there is more than one context
			if (X.RDB$VIEW_CONTEXT != 1 || X.RDB$CONTEXT_TYPE == VCT_PROCEDURE)
			{
				relation = NULL;
				cont = false;
				break;
			}

			fb_utils::exact_name(X.RDB$CONTEXT_NAME);
			fb_utils::exact_name(X.RDB$RELATION_NAME);

			relation = METD_get_relation(transaction, dsqlScratch, X.RDB$RELATION_NAME);

			Array<MetaName> ambiguities;
			MetaNamePairMap currentAux;

			if (!relation)
			{
				cont = false;
				break;
			}

			AutoCacheRequest handle2(tdbb, irq_view_base_flds, IRQ_REQUESTS);

			FOR(REQUEST_HANDLE handle2 TRANSACTION_HANDLE transaction)
				RFL IN RDB$RELATION_FIELDS
				WITH RFL.RDB$RELATION_NAME EQ X.RDB$VIEW_NAME
			{
				if (RFL.RDB$BASE_FIELD.NULL || RFL.RDB$FIELD_NAME.NULL)
					continue;

				const MetaName baseField(RFL.RDB$BASE_FIELD);
				if (currentAux.exist(baseField))
					ambiguities.add(baseField);
				else
				{
					const MetaName fieldName(RFL.RDB$FIELD_NAME);
					if (first)
					{
						fields.put(fieldName, baseField);
						currentAux.put(baseField, fieldName);
					}
					else
					{
						MetaName field;

						if (previousAux.get(fieldName, field))
						{
							fields.put(field, baseField);
							currentAux.put(baseField, field);
						}
					}
				}
			}
			END_FOR

			for (const MetaName* i = ambiguities.begin(); i != ambiguities.end(); ++i)
			{
				MetaName field;

				if (currentAux.get(*i, field))
				{
					currentAux.remove(*i);
					fields.remove(field);
				}
			}

			previousAux.takeOwnership(currentAux);

			if (relation->rel_flags & REL_view)
				view_name = X.RDB$RELATION_NAME;
			else
			{
				cont = false;
				break;
			}

			first = false;
		}
		END_FOR
	}

	if (!relation)
		fields.clear();

	return relation;
}


bool METD_get_view_relation(jrd_tra* transaction, DsqlCompilerScratch* dsqlScratch,
	const Jrd::MetaName& view_name, const Jrd::MetaName& relation_or_alias,
	dsql_rel*& relation, dsql_prc*& procedure)
{
/**************************************
 *
 *  M E T D _ g e t _ v i e w _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *  Return TRUE if the passed view_name represents a
 *  view with the passed relation as a base table
 *  (the relation could be an alias).
 *
 **************************************/
	thread_db* tdbb = JRD_get_thread_data();

	validateTransaction(transaction);

	AutoCacheRequest handle(tdbb, irq_view, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		X IN RDB$VIEW_RELATIONS WITH X.RDB$VIEW_NAME EQ view_name.c_str()
	{
		fb_utils::exact_name(X.RDB$CONTEXT_NAME);
		fb_utils::exact_name(X.RDB$RELATION_NAME);

		if (relation_or_alias == X.RDB$RELATION_NAME ||
			relation_or_alias == X.RDB$CONTEXT_NAME)
		{
			if ( (relation = METD_get_relation(transaction, dsqlScratch, X.RDB$RELATION_NAME)) )
				return true;

			const QualifiedName procName(X.RDB$RELATION_NAME,
				X.RDB$PACKAGE_NAME.NULL ? nullptr : X.RDB$PACKAGE_NAME);

			if ( (procedure = METD_get_procedure(transaction, dsqlScratch, procName)) )
				return true;
		}

		if (METD_get_view_relation(transaction, dsqlScratch, X.RDB$RELATION_NAME,
			relation_or_alias, relation, procedure))
		{
			return true;
		}
	}
	END_FOR

	return false;
}


static void convert_dtype(TypeClause* field, SSHORT field_type)
{
/**************************************
 *
 *  c o n v e r t _ d t y p e
 *
 **************************************
 *
 * Functional description
 *  Convert from the blr_<type> stored in system metadata
 *  to the internal dtype_* descriptor.  Also set field
 *  length.
 *
 **************************************/

	// fill out the type descriptor
	switch (field_type)
	{
	case blr_text:
		field->dtype = dtype_text;
		break;
	case blr_varying:
		field->dtype = dtype_varying;
		field->length += sizeof(USHORT);
		break;
	case blr_blob:
		field->dtype = dtype_blob;
		field->length = type_lengths[field->dtype];
		break;
	default:
		field->dtype = gds_cvt_blr_dtype[field_type];
		field->length = type_lengths[field->dtype];

		fb_assert(field->dtype != dtype_unknown);
	}
}

