/*
 *  The contents of this file are subject to the Initial
 *  Developer's Public License Version 1.0 (the "License");
 *  you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.
 *
 *  Software distributed under the License is distributed AS IS,
 *  WITHOUT WARRANTY OF ANY KIND, either express or implied.
 *  See the License for the specific language governing rights
 *  and limitations under the License.
 *
 *  The Original Code was created by Adriano dos Santos Fernandes
 *  for the Firebird Open Source RDBMS project.
 *
 *  Copyright (c) 2009 Adriano dos Santos Fernandes <adrianosf@uol.com.br>
 *  and all contributors signed below.
 *
 *  All Rights Reserved.
 *  Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include "../dsql/PackageNodes.h"
#include "../jrd/dyn.h"
#include "../jrd/intl.h"
#include "../jrd/jrd.h"
#include "../jrd/tra.h"
#include "../jrd/dfw_proto.h"
#include "../jrd/dyn_ut_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/vio_proto.h"
#include "../dsql/make_proto.h"
#include "../dsql/pass1_proto.h"
#include "../common/StatusArg.h"
#include "../common/classes/TriState.h"
#include "../jrd/Attachment.h"
#include "../jrd/scl_proto.h"

#include "../common/dsc_proto.h" // DSC_make_descriptor
#include "../jrd/Constant.h" // Constant

#include "../dsql/metd_proto.h" // METD_get_domain
#include "../common/classes/VaryStr.h" // METD_get_domain
#include "../jrd/par_proto.h" // PAR_proto in Nodes.h (dependency hell)
#include "../jrd/met.h" // Metacache
#include "../jrd/Statement.h" // Jrd::Statement

using namespace Firebird;

namespace Jrd {

using namespace Firebird;

DATABASE DB = STATIC "ODS.RDB";


//----------------------


namespace
{

class DropConstantNode
{
public:
	DropConstantNode(Firebird::MemoryPool& pool, const QualifiedName& fullName) :
		m_name(pool, fullName)
	{ }

	void dsqlPass(DsqlCompilerScratch* dsqlScratch)
	{
		dsqlScratch->qualifyExistingName(m_name, obj_package_constant);
	}

	void execute(thread_db* tdbb, DsqlCompilerScratch*, jrd_tra* transaction)
	{
		Constant::drop(tdbb, transaction, m_name);
	}

private:
	QualifiedName m_name;
};


template<class TDropNode>
void dropItem(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, const QualifiedName& fullName)
{
	MemoryPool& pool = dsqlScratch->getPool();
	jrd_tra* transaction = dsqlScratch->getTransaction();

	TDropNode dropNode(pool, fullName);
	dropNode.dsqlPass(dsqlScratch);
	dropNode.execute(tdbb, dsqlScratch, transaction);
}

template<class TDropNode>
void dropMissingItems(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, const QualifiedName& packageAndSchema,
	const PackageItemsHolder::ItemsSignatureArray& existsItems,
	const CreateAlterPackageNode::ItemsNameArray& newNames)
{
	for (auto i = existsItems.begin(); i != existsItems.end(); ++i)
	{
		if (!newNames.exist(i->name))
		{
			dropItem<TDropNode>(tdbb, dsqlScratch,
				QualifiedName(i->name, packageAndSchema.schema, packageAndSchema.object));
		}
	}
}

template<class TDropNode>
void dropItems(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, const QualifiedName& packageAndSchema,
	const PackageItemsHolder::ItemsSignatureArray& items)
{
	for (auto i = items.begin(); i != items.end(); ++i)
	{
		dropItem<TDropNode>(tdbb, dsqlScratch,
			QualifiedName(i->name, packageAndSchema.schema, packageAndSchema.object));
	}
}

void checkItemsDefineMatch(MemoryPool& pool, const QualifiedName& packageAndSchema,
	const PackageItemsHolder::ItemsSignatureArray& newItems,
	const PackageItemsHolder::ItemsSignatureArray& existingItems,
	ISC_STATUS missingCode, ISC_STATUS mismatchCode)
{
	for (auto i = existingItems.begin(); i != existingItems.end(); ++i)
	{
		FB_SIZE_T pos;
		bool found = newItems.find(Signature(pool, i->name), pos);

		if (!found || !newItems[pos].defined)
		{
			status_exception::raise(
				Arg::Gds(missingCode) << i->name << packageAndSchema.toQuotedString());
		}
		else if (newItems[pos] != *i)
		{
			status_exception::raise(
				Arg::Gds(mismatchCode) << i->name << packageAndSchema.toQuotedString());
		}
	}
}

}	// namespace


//----------------------

void PackageItemsHolder::drop(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, const QualifiedName& packageAndSchema)
{
	dropItems<DropFunctionNode>(tdbb, dsqlScratch, packageAndSchema, functions);
	dropItems<DropProcedureNode>(tdbb, dsqlScratch, packageAndSchema, procedures);
	dropItems<DropConstantNode>(tdbb, dsqlScratch, packageAndSchema, constants);
}

void PackageItemsHolder::checkDefineMatch(MemoryPool& pool, const QualifiedName& packageAndSchema,
	const PackageItemsHolder& newItems)
{
	checkItemsDefineMatch(pool, packageAndSchema, newItems.functions, functions,
		isc_dyn_funcnotdef_package, isc_dyn_funcsignat_package);
	checkItemsDefineMatch(pool, packageAndSchema, newItems.procedures, procedures,
		isc_dyn_procnotdef_package, isc_dyn_procsignat_package);
}

	// Return function and procedure names (in the user charset) and optionally its details for a
	// given package.
void PackageItemsHolder::collectPackagedItems(thread_db* tdbb, jrd_tra* transaction,
	const QualifiedName& packageName,
	bool details, bool collectConstants)
{
	AutoCacheRequest requestHandle(tdbb, drq_l_pkg_funcs, DYN_REQUESTS);
	AutoCacheRequest requestHandle2(tdbb, drq_l_pkg_func_args, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		FUN IN RDB$FUNCTIONS
		WITH FUN.RDB$SCHEMA_NAME EQ packageName.schema.c_str() AND
				FUN.RDB$PACKAGE_NAME EQ packageName.object.c_str()
	{
		Signature function(FUN.RDB$FUNCTION_NAME);
		function.defined = !FUN.RDB$FUNCTION_BLR.NULL || !FUN.RDB$ENTRYPOINT.NULL;

		if (!FUN.RDB$DETERMINISTIC_FLAG.NULL && FUN.RDB$DETERMINISTIC_FLAG != 0)
			function.flags |= Signature::FLAG_DETERMINISTIC;

		if (details)
		{
			FOR (REQUEST_HANDLE requestHandle2 TRANSACTION_HANDLE transaction)
				ARG IN RDB$FUNCTION_ARGUMENTS CROSS
				FLD IN RDB$FIELDS
				WITH ARG.RDB$SCHEMA_NAME EQ FUN.RDB$SCHEMA_NAME AND
						ARG.RDB$PACKAGE_NAME EQ FUN.RDB$PACKAGE_NAME AND
						ARG.RDB$FUNCTION_NAME EQ FUN.RDB$FUNCTION_NAME AND
						FLD.RDB$SCHEMA_NAME EQUIV ARG.RDB$FIELD_SOURCE_SCHEMA_NAME AND
						FLD.RDB$FIELD_NAME EQ ARG.RDB$FIELD_SOURCE
			{
				SignatureParameter parameter(*getDefaultMemoryPool());

				parameter.number = ARG.RDB$ARGUMENT_POSITION;
				parameter.name = ARG.RDB$ARGUMENT_NAME;
				parameter.fieldSource = QualifiedName(ARG.RDB$FIELD_SOURCE, ARG.RDB$FIELD_SOURCE_SCHEMA_NAME);
				parameter.mechanism = ARG.RDB$ARGUMENT_MECHANISM;

				if (!ARG.RDB$FIELD_NAME.NULL)
					parameter.fieldName = QualifiedName(ARG.RDB$FIELD_NAME);
				if (!ARG.RDB$RELATION_NAME.NULL)
					parameter.relationName = QualifiedName(ARG.RDB$RELATION_NAME, ARG.RDB$RELATION_SCHEMA_NAME);
				if (!ARG.RDB$COLLATION_ID.NULL)
					parameter.collationId = CollId(ARG.RDB$COLLATION_ID);
				if (!ARG.RDB$NULL_FLAG.NULL)
					parameter.nullFlag = ARG.RDB$NULL_FLAG;

				if (!FLD.RDB$FIELD_LENGTH.NULL)
					parameter.fieldLength = FLD.RDB$FIELD_LENGTH;
				if (!FLD.RDB$FIELD_SCALE.NULL)
					parameter.fieldScale = FLD.RDB$FIELD_SCALE;
				if (!FLD.RDB$FIELD_TYPE.NULL)
					parameter.fieldType = FLD.RDB$FIELD_TYPE;
				if (!FLD.RDB$FIELD_SUB_TYPE.NULL)
					parameter.fieldSubType = FLD.RDB$FIELD_SUB_TYPE;
				if (!FLD.RDB$SEGMENT_LENGTH.NULL)
					parameter.fieldSegmentLength = FLD.RDB$SEGMENT_LENGTH;
				if (!FLD.RDB$NULL_FLAG.NULL)
					parameter.fieldNullFlag = FLD.RDB$NULL_FLAG;
				if (!FLD.RDB$CHARACTER_LENGTH.NULL)
					parameter.fieldCharLength = FLD.RDB$CHARACTER_LENGTH;
				if (!FLD.RDB$COLLATION_ID.NULL)
					parameter.fieldCollationId = CollId(FLD.RDB$COLLATION_ID);
				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					parameter.fieldCharSetId = CSetId(FLD.RDB$CHARACTER_SET_ID);
				if (!FLD.RDB$FIELD_PRECISION.NULL)
					parameter.fieldPrecision = FLD.RDB$FIELD_PRECISION;

				function.parameters.add(parameter);
			}
			END_FOR
		}

		functions.add(function);
	}
	END_FOR

	requestHandle.reset(tdbb, drq_l_pkg_procs, DYN_REQUESTS);
	requestHandle2.reset(tdbb, drq_l_pkg_proc_args, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PRC IN RDB$PROCEDURES
		WITH PRC.RDB$SCHEMA_NAME EQ packageName.schema.c_str() AND
				PRC.RDB$PACKAGE_NAME EQ packageName.object.c_str()
	{
		Signature procedure(PRC.RDB$PROCEDURE_NAME);
		procedure.defined = !PRC.RDB$PROCEDURE_BLR.NULL || !PRC.RDB$ENTRYPOINT.NULL;

		if (details)
		{
			FOR (REQUEST_HANDLE requestHandle2 TRANSACTION_HANDLE transaction)
				PRM IN RDB$PROCEDURE_PARAMETERS CROSS
				FLD IN RDB$FIELDS
				WITH PRM.RDB$SCHEMA_NAME EQ PRC.RDB$SCHEMA_NAME AND
						PRM.RDB$PACKAGE_NAME EQ PRC.RDB$PACKAGE_NAME AND
						PRM.RDB$PROCEDURE_NAME EQ PRC.RDB$PROCEDURE_NAME AND
						FLD.RDB$SCHEMA_NAME EQUIV PRM.RDB$FIELD_SOURCE_SCHEMA_NAME AND
						FLD.RDB$FIELD_NAME EQ PRM.RDB$FIELD_SOURCE
			{
				SignatureParameter parameter(*getDefaultMemoryPool());
				parameter.type = PRM.RDB$PARAMETER_TYPE;
				parameter.number = PRM.RDB$PARAMETER_NUMBER;
				parameter.name = PRM.RDB$PARAMETER_NAME;
				parameter.fieldSource = QualifiedName(PRM.RDB$FIELD_SOURCE, PRM.RDB$FIELD_SOURCE_SCHEMA_NAME);
				parameter.mechanism = PRM.RDB$PARAMETER_MECHANISM;

				if (!PRM.RDB$FIELD_NAME.NULL)
					parameter.fieldName = QualifiedName(PRM.RDB$FIELD_NAME);
				if (!PRM.RDB$RELATION_NAME.NULL)
					parameter.relationName = QualifiedName(PRM.RDB$RELATION_NAME, PRM.RDB$RELATION_SCHEMA_NAME);
				if (!PRM.RDB$COLLATION_ID.NULL)
					parameter.collationId = CollId(PRM.RDB$COLLATION_ID);
				if (!PRM.RDB$NULL_FLAG.NULL)
					parameter.nullFlag = PRM.RDB$NULL_FLAG;

				if (!FLD.RDB$FIELD_LENGTH.NULL)
					parameter.fieldLength = FLD.RDB$FIELD_LENGTH;
				if (!FLD.RDB$FIELD_SCALE.NULL)
					parameter.fieldScale = FLD.RDB$FIELD_SCALE;
				if (!FLD.RDB$FIELD_TYPE.NULL)
					parameter.fieldType = FLD.RDB$FIELD_TYPE;
				if (!FLD.RDB$FIELD_SUB_TYPE.NULL)
					parameter.fieldSubType = FLD.RDB$FIELD_SUB_TYPE;
				if (!FLD.RDB$SEGMENT_LENGTH.NULL)
					parameter.fieldSegmentLength = FLD.RDB$SEGMENT_LENGTH;
				if (!FLD.RDB$NULL_FLAG.NULL)
					parameter.fieldNullFlag = FLD.RDB$NULL_FLAG;
				if (!FLD.RDB$CHARACTER_LENGTH.NULL)
					parameter.fieldCharLength = FLD.RDB$CHARACTER_LENGTH;
				if (!FLD.RDB$COLLATION_ID.NULL)
					parameter.fieldCollationId = CollId(FLD.RDB$COLLATION_ID);
				if (!FLD.RDB$CHARACTER_SET_ID.NULL)
					parameter.fieldCharSetId = CSetId(FLD.RDB$CHARACTER_SET_ID);
				if (!FLD.RDB$FIELD_PRECISION.NULL)
					parameter.fieldPrecision = FLD.RDB$FIELD_PRECISION;

				procedure.parameters.add(parameter);
			}
			END_FOR
		}

		procedures.add(procedure);
	}
	END_FOR


	if (collectConstants)
	{
		static const CachedRequestId requestId;
		AutoCacheRequest getConstantsRequest(tdbb, requestId);
		FOR (REQUEST_HANDLE getConstantsRequest TRANSACTION_HANDLE transaction)
			CONST IN RDB$CONSTANTS WITH
				CONST.RDB$SCHEMA_NAME EQ packageName.schema.c_str() AND
				CONST.RDB$PACKAGE_NAME EQ packageName.object.c_str()
		{

			Signature constant(CONST.RDB$CONSTANT_NAME);
			constants.add(constant);
		}
		END_FOR
	}
}

void PackageItemsHolder::clear()
{
	functions.clear();
	procedures.clear();
}

//----------------------


// -----------------------------------
// PackageReferenceNode implementation
// -----------------------------------

static RegisterNode<PackageReferenceNode> regPackageReferenceNode({blr_package_reference});

PackageReferenceNode::PackageReferenceNode(MemoryPool& pool, const QualifiedName& fullName, const UCHAR itemType)
		: TypedNode<ValueExprNode, ExprNode::TYPE_REFERENCE>(pool),
		m_fullName(fullName.object, fullName.schema.hasData() ? fullName.schema : PUBLIC_SCHEMA, fullName.package), m_itemType(itemType)
{}

string PackageReferenceNode::internalPrint(NodePrinter& printer) const
{
	ExprNode::internalPrint(printer);

	NODE_PRINT(printer, m_fullName);

	return "PackageReferenceNode";
}

ValueExprNode* PackageReferenceNode::dsqlPass(DsqlCompilerScratch* dsqlScratch)
{
	MemoryPool& pool = dsqlScratch->getPool();

	jrd_tra* transaction = dsqlScratch->getTransaction();
	thread_db* tdbb = JRD_get_thread_data();

	bool isPrivate = false;
	if (constantExists(tdbb, transaction, m_fullName, &isPrivate))
	{
		// External objects do not have access to private constants.
		if (isPrivate)
		{
			status_exception::raise(Arg::Gds(isc_private_constant) <<
				Arg::Str(m_fullName.toQuotedString()));
		}
	}
	else
	{
		status_exception::raise(Arg::Gds(isc_not_defined_constant) <<
			Arg::Str(m_fullName.toQuotedString()));
	}

	auto* node = FB_NEW_POOL(pool) PackageReferenceNode(pool, m_fullName, m_itemType);
	return node;
}


DmlNode* PackageReferenceNode::parse(thread_db* tdbb, MemoryPool& pool, CompilerScratch* csb, const UCHAR)
{
	const UCHAR itemType = csb->csb_blr_reader.getByte();

	switch (itemType)
	{
	case blr_pkg_ref_item_const:
	{
		QualifiedName fullName;
		csb->csb_blr_reader.getMetaName(fullName.object);
		csb->csb_blr_reader.getMetaName(fullName.schema);
		csb->csb_blr_reader.getMetaName(fullName.package);

		PackageReferenceNode* node = FB_NEW_POOL(pool) PackageReferenceNode(pool, fullName, itemType);

		if (csb->collectingDependencies())
		{
			Dependency dependency(obj_package_constant);
			dependency.name = FB_NEW_POOL(pool) QualifiedName(pool, fullName);

			csb->addDependency(dependency);
		}

		{
			csb->qualifyExistingName(tdbb, fullName, obj_package_constant);
			auto* constant = MetadataCache::getPerm<Cached::Constant>(tdbb, fullName, CacheFlag::AUTOCREATE);
			if (constant)
				node->m_constant = csb->csb_resources->constants.registerResource(constant);
		}

		if (!node->m_constant)
			status_exception::raise(Arg::Gds(isc_bad_constant_name) <<
				Arg::Str(fullName.toQuotedString()));

		return node;
	}
	// TODO: rowtype
	default:
		fb_assert(false);
	}

	return nullptr;
}


void PackageReferenceNode::genBlr(DsqlCompilerScratch* dsqlScratch)
{
	dsqlScratch->appendUChar(blr_package_reference);
	dsqlScratch->appendUChar(blr_pkg_ref_item_const);
	dsqlScratch->appendMetaString(m_fullName.object.c_str());
	dsqlScratch->appendMetaString(m_fullName.schema.c_str());
	dsqlScratch->appendMetaString(m_fullName.package.c_str());
}

void PackageReferenceNode::setParameterName(dsql_par* parameter) const
{
	parameter->par_name = parameter->par_alias = m_fullName.object;
}

void PackageReferenceNode::make(DsqlCompilerScratch* dsqlScratch, dsc* desc)
{
	jrd_tra* transaction = dsqlScratch->getTransaction();
	thread_db* tdbb = JRD_get_thread_data();
	*desc = Constant::getDesc(tdbb, transaction, m_fullName);
}

bool PackageReferenceNode::constantExists(thread_db* tdbb, Jrd::jrd_tra* transaction,
	const QualifiedName& fullName, bool* isPrivate)
{
	if (fullName.package.isEmpty() || fullName.object.isEmpty())
		return false;

	// Use default schema if one not specified
	const char* schemaName = fullName.schema.hasData() ? fullName.schema.c_str() : PUBLIC_SCHEMA;

	static const CachedRequestId requestId;
	AutoCacheRequest getConstantRequest(tdbb, requestId);
	FOR (REQUEST_HANDLE getConstantRequest TRANSACTION_HANDLE transaction)
		CONST IN RDB$CONSTANTS
		WITH CONST.RDB$SCHEMA_NAME EQ schemaName AND
		CONST.RDB$PACKAGE_NAME EQ fullName.package.c_str() AND
		CONST.RDB$CONSTANT_NAME EQ fullName.object.c_str()
	{
		if (isPrivate)
		{
			*isPrivate = !CONST.RDB$PRIVATE_FLAG.NULL && CONST.RDB$PRIVATE_FLAG;
		}

		return true;
	}
	END_FOR

	return false;
}

void PackageReferenceNode::getDesc(thread_db* tdbb, CompilerScratch*, dsc* desc)
{
	*desc = Constant::getDesc(tdbb, tdbb->getTransaction(), m_fullName);
}

ValueExprNode* PackageReferenceNode::copy(thread_db* tdbb, NodeCopier& copier) const
{
	MemoryPool& pool = *tdbb->getDefaultPool();
	auto* node = FB_NEW_POOL(pool) PackageReferenceNode(pool, m_fullName, m_itemType);

	auto* constant = MetadataCache::getPerm<Cached::Constant>(tdbb, m_fullName, 0);
	node->m_constant = copier.csb->csb_resources->constants.registerResource(constant);

	return node;
}

ValueExprNode* PackageReferenceNode::pass2(thread_db* tdbb, CompilerScratch* csb)
{
	ValueExprNode::pass2(tdbb, csb);

	if (m_itemType == blr_pkg_ref_item_const)
		m_impureOffset = csb->allocImpure<impure_value>();

	return this;
}

dsc* PackageReferenceNode::execute(thread_db* tdbb, Request* request) const
{
	impure_value* impure = request->getImpure<impure_value>(m_impureOffset);
	switch (m_itemType)
	{
	case blr_pkg_ref_item_const:
	{
		const Constant* constant = m_constant(request->getResources());
		constant->checkReload(tdbb);

		EVL_make_value(tdbb, &constant->getValue(), impure);
		return &impure->vlu_desc;
	}
	default:
		fb_assert(false);
		return nullptr;
	}
}


// ----------------------------------------
// CreatePackageConstantNode
// ----------------------------------------

string CreatePackageConstantNode::internalPrint(NodePrinter& printer) const
{
	DdlNode::internalPrint(printer);

	NODE_PRINT(printer, name);
	NODE_PRINT(printer, m_type);
	NODE_PRINT(printer, m_expr);
	NODE_PRINT(printer, m_isPrivate);

	return "PackageReferenceNode";
}

DdlNode* CreatePackageConstantNode::dsqlPass(DsqlCompilerScratch* dsqlScratch)
{
	dsqlScratch->qualifyNewName(name);

	m_expr = m_expr->dsqlPass(dsqlScratch);

	QualifiedName dummyCollationName;
	DDL_resolve_intl_type(dsqlScratch, m_type, dummyCollationName);

	if (!m_expr->constant())
	{
		status_exception::raise(Arg::Gds(isc_dyn_non_constant_constant) << name.toQuotedString());
	}
	// DsqlDescMaker::fromField(&node->castDesc, type);
	// node->castDesc.dsc_flags = node->source->getDsqlDesc().dsc_flags & DSC_nullable;

	DdlNode::dsqlPass(dsqlScratch);
	return nullptr;
}

void CreatePackageConstantNode::checkPermission(thread_db* tdbb, jrd_tra* transaction)
{
	// SCL_check_create_access(tdbb, obj_package_constant);
}

void CreatePackageConstantNode::execute(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, jrd_tra* transaction)
{
	if (create)
	{
		if (alter && executeAlter(tdbb, dsqlScratch, transaction))
		{
			return;
		}

		executeCreate(tdbb, dsqlScratch, transaction);
	}
	else
		executeAlter(tdbb, dsqlScratch, transaction);

	fb_assert(m_id);
	MetadataCache::newVersion<Cached::Constant>(tdbb, m_id);
}

void CreatePackageConstantNode::executeCreate(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, jrd_tra* transaction)
{
	FbLocalStatus status;

	static const CachedRequestId requestId;
	AutoCacheRequest storeConstantRequest(tdbb, requestId);

	// Check uniqueness
	if (PackageReferenceNode::constantExists(tdbb, transaction, name))
	{
		status_exception::raise(Arg::Gds(isc_dyn_dup_const) << name.toQuotedString());
	}

	// Generate a new unique field name because constants in different packages may have same name
	// but names in RDB$FIELDS should be unique in for a SCHEME
	QualifiedName fieldName = name;
	fieldName.object = "";
	// Store description in the RDB$FIELDS relation
	storeGlobalField(tdbb, tdbb->getTransaction(), fieldName, m_type);
	fb_assert(fieldName.schema == name.schema);
	fb_assert(fieldName.package == name.package);

	int faults = 0;
	while (true)
	{
		try
		{
			SINT64 id = DYN_UTIL_gen_unique_id(tdbb, drq_g_nxt_const_id, "RDB$CONSTANTS");
			id %= (MAX_SSHORT + 1);
			if (!id)
				continue;

			m_id = id;

			// Store desc and metainfo in the RDB$CONSTANTS relation
			STORE (REQUEST_HANDLE storeConstantRequest TRANSACTION_HANDLE transaction)
				CONST IN RDB$CONSTANTS USING
			{
				// Constant name
				CONST.RDB$CONSTANT_NAME.NULL = FALSE;
				strcpy(CONST.RDB$CONSTANT_NAME, name.object.c_str());

				// Constant unique id
				CONST.RDB$CONSTANT_ID = id;

				// Description (filed) name
				CONST.RDB$FIELD_SOURCE.NULL = FALSE;
				strcpy(CONST.RDB$FIELD_SOURCE, fieldName.object.c_str());

				// Gen value blr
				Constant::genConstantBlr(tdbb, dsqlScratch, m_expr, m_type, name.schema);

				// Put the blr
				blb* blob = blb::create(tdbb, transaction, &CONST.RDB$CONSTANT_BLR);
				blob->BLB_put_segment(tdbb, dsqlScratch->getBlrData().begin(), dsqlScratch->getBlrData().getCount());
				blob->BLB_close(tdbb);

				// Parent package
				CONST.RDB$PACKAGE_NAME.NULL = FALSE;
				strcpy(CONST.RDB$PACKAGE_NAME, name.package.c_str());

				// Schema of the parent package
				CONST.RDB$SCHEMA_NAME.NULL = FALSE;
				strcpy(CONST.RDB$SCHEMA_NAME, name.schema.c_str());

				// Type
				CONST.RDB$PRIVATE_FLAG.NULL = FALSE;
				CONST.RDB$PRIVATE_FLAG = m_isPrivate;

				CONST.RDB$CONSTANT_SOURCE.NULL = TRUE;
			}
			END_STORE
			break;
		}
		catch (const status_exception& ex)
		{
			if (ex.value()[1] != isc_unique_key_violation)
				throw;

			if (++faults > MAX_SSHORT)
				throw;

			fb_utils::init_status(tdbb->tdbb_status_vector);
		}
	}// While
}


bool CreatePackageConstantNode::executeAlter(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, jrd_tra* transaction)
{
	FbLocalStatus status;

	static const CachedRequestId eraseRequestId;
	AutoCacheRequest eraseDscRequest(tdbb, eraseRequestId);

	static const CachedRequestId modifyRequestId;
	AutoCacheRequest modifyConstantRequest(tdbb, modifyRequestId);
	bid blobId;

	bool found = false;

	// Get existing filed
	// Store constant dsc in RDB$FIELDS
	FOR (REQUEST_HANDLE eraseDscRequest TRANSACTION_HANDLE transaction)
		FLD IN RDB$FIELDS CROSS CONST IN RDB$CONSTANTS
			WITH CONST.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
				CONST.RDB$PACKAGE_NAME EQ name.package.c_str() AND
				CONST.RDB$CONSTANT_NAME EQ name.object.c_str() AND
				FLD.RDB$SCHEMA_NAME EQ CONST.RDB$SCHEMA_NAME AND
				FLD.RDB$FIELD_NAME EQ CONST.RDB$FIELD_SOURCE
	{
		m_id = CONST.RDB$CONSTANT_ID;

		MetadataCache::oldVersion<Cached::Constant>(tdbb, m_id, CacheFlag::OLD_ALTER);

		dyn_fld origDom, newDom;
		DSC_make_descriptor(&origDom.dyn_dsc, FLD.RDB$FIELD_TYPE, FLD.RDB$FIELD_SCALE,
			FLD.RDB$FIELD_LENGTH, FLD.RDB$FIELD_SUB_TYPE,
			CSetId(FLD.RDB$CHARACTER_SET_ID),
			CollId(FLD.RDB$COLLATION_ID));

		origDom.dyn_fld_name = name;
		origDom.dyn_charbytelen = FLD.RDB$FIELD_LENGTH;
		origDom.dyn_dtype = FLD.RDB$FIELD_TYPE;
		origDom.dyn_precision = FLD.RDB$FIELD_PRECISION;
		origDom.dyn_sub_type = FLD.RDB$FIELD_SUB_TYPE;
		origDom.dyn_charlen = FLD.RDB$CHARACTER_LENGTH;
		origDom.dyn_collation = FLD.RDB$COLLATION_ID;
		origDom.dyn_null_flag = !FLD.RDB$NULL_FLAG.NULL && FLD.RDB$NULL_FLAG != 0;
		origDom.dyn_fld_source = QualifiedName(CONST.RDB$FIELD_SOURCE, CONST.RDB$SCHEMA_NAME, CONST.RDB$PACKAGE_NAME);

		// If the original field type is an array, force its blr type to blr_blob
		if (FLD.RDB$DIMENSIONS != 0)
			origDom.dyn_dtype = blr_blob;

		const bool wasInternalDomain = fb_utils::implicit_domain(origDom.dyn_fld_source.object.c_str());

		QualifiedName newDomainName;

		// We have the type. Default and type/domain are exclusive for now.
		if (m_type->typeOfName.object.hasData())
		{
			// Case a1: Internal domain -> domain.
			// Case a2: Domain -> domain.

			newDomainName = m_type->typeOfName;

			if (fb_utils::implicit_domain(newDomainName.object.c_str()))
			{
				// msg 224: "Cannot use the internal domain %s as new type for field %s".
				status_exception::raise(
					Arg::PrivateDyn(224) << newDomainName.toQuotedString() << m_type->fld_name);
			}

			// Get the domain information.
			if (!METD_get_domain(dsqlScratch->getTransaction(), m_type, newDomainName))
			{
				// Specified domain or source field does not exist.
				status_exception::raise(
					Arg::Gds(isc_sqlerr) << Arg::Num(-607) <<
					Arg::Gds(isc_dsql_command_err) <<
					Arg::Gds(isc_dsql_domain_not_found) << newDomainName.toQuotedString());
			}

			QualifiedName dummyCollationName;
			DDL_resolve_intl_type(dsqlScratch, m_type, dummyCollationName);

			// If the original definition was a base field type, remove the
			// entries from RDB$FIELDS.
			if (wasInternalDomain)
			{
				// Case a1: Internal domain -> domain.
				ERASE FLD;
			}
		}
		else
		{
			// Case b1: Internal domain -> internal domain.
			// Case b2: Domain -> internal domain.

			m_type->resolve(dsqlScratch, true);

			if (wasInternalDomain)	// Case b1: Internal domain -> internal domain.
			{
				MODIFY FLD
					updateRdbFields(m_type,
						FLD.RDB$FIELD_TYPE,
						FLD.RDB$FIELD_LENGTH,
						FLD.RDB$FIELD_SUB_TYPE.NULL, FLD.RDB$FIELD_SUB_TYPE,
						FLD.RDB$FIELD_SCALE.NULL, FLD.RDB$FIELD_SCALE,
						FLD.RDB$CHARACTER_SET_ID.NULL, FLD.RDB$CHARACTER_SET_ID,
						FLD.RDB$CHARACTER_LENGTH.NULL, FLD.RDB$CHARACTER_LENGTH,
						FLD.RDB$FIELD_PRECISION.NULL, FLD.RDB$FIELD_PRECISION,
						FLD.RDB$COLLATION_ID.NULL, FLD.RDB$COLLATION_ID,
						FLD.RDB$SEGMENT_LENGTH.NULL, FLD.RDB$SEGMENT_LENGTH);
				END_MODIFY

				newDom.dyn_fld_source = origDom.dyn_fld_source;
			}
			else	// Case b2: Domain -> internal domain.
				storeGlobalField(tdbb, transaction, newDomainName, m_type);
		}


		if (newDomainName.object.hasData())
			newDom.dyn_fld_source = newDomainName;

		AlterDomainNode::getDomainType(tdbb, transaction, newDom);

		if (newDom.dyn_dtype == blr_blob && newDomainName.object.isEmpty())
			newDom.dyn_sub_type = m_type->subType;

		// Gen the new constant value as blr
		Constant::genConstantBlr(tdbb, dsqlScratch, m_expr, m_type, name.schema);

		// And write
		blb* blob = blb::create(tdbb, transaction, &blobId);
		blob->BLB_put_segment(tdbb, dsqlScratch->getBlrData().begin(), dsqlScratch->getBlrData().getCount());
		blob->BLB_close(tdbb);

		MODIFY CONST USING
			CONST.RDB$CONSTANT_BLR.NULL = FALSE;
			CONST.RDB$CONSTANT_BLR = blobId;
		END_MODIFY

		found = true;
	}
	END_FOR

	return found;
}


string CreateAlterPackageNode::internalPrint(NodePrinter& printer) const
{
	DdlNode::internalPrint(printer);

	NODE_PRINT(printer, name);
	NODE_PRINT(printer, create);
	NODE_PRINT(printer, alter);
	NODE_PRINT(printer, source);
	//// FIXME-PRINT: NODE_PRINT(printer, items);
	NODE_PRINT(printer, functionNames);
	NODE_PRINT(printer, procedureNames);
	NODE_PRINT(printer, constantNames);

	return "CreateAlterPackageNode";
}


DdlNode* CreateAlterPackageNode::dsqlPass(DsqlCompilerScratch* dsqlScratch)
{
	if (create)
		dsqlScratch->qualifyNewName(name);
	else
		dsqlScratch->qualifyExistingName(name, obj_package_header);

	protectSystemSchema(name.schema, obj_package_header);
	dsqlScratch->ddlSchema = name.schema;

	if (alter && !items)
		return DdlNode::dsqlPass(dsqlScratch);

	MemoryPool& pool = dsqlScratch->getPool();

	source.ltrim("\n\r\t ");

	// items
	for (unsigned i = 0; i < items->getCount(); ++i)
	{
		DdlNode* ddlNode;

		switch ((*items)[i].type)
		{
			case PackageItemType::FUNCTION:
			{
				CreateAlterFunctionNode* const fun = (*items)[i].function;
				ddlNode = fun;

				functionNames.addName<PackageItemType::FUNCTION>(fun->name);

				fun->alter = true;
				fun->name.schema = name.schema;
				fun->name.package = name.object;
				break;
			}

			case PackageItemType::PROCEDURE:
			{
				CreateAlterProcedureNode* const proc = (*items)[i].procedure;
				ddlNode = proc;

				procedureNames.addName<PackageItemType::PROCEDURE>(proc->name);

				proc->alter = true;
				proc->name.schema = name.schema;
				proc->name.package = name.object;
				break;
			}
			case PackageItemType::CONSTANT:
			{
				CreatePackageConstantNode* const constant = (*items)[i].constant;
				ddlNode = constant;
				constantNames.addName<PackageItemType::CONSTANT>(constant->name);

				constant->create = true; // Create a new constant
				constant->alter = true; // Create a new constant
				constant->name.schema = name.schema;
				constant->name.package = name.object;
				constant->makePublic();
				break;
			}

			default:
				ddlNode = nullptr; // Warning
				fb_assert(false);
		}

		auto itemStatement = FB_NEW_POOL(pool) DsqlDdlStatement(pool, dsqlScratch->getAttachment(), ddlNode);

		auto itemScratch = (*items)[i].dsqlScratch =
			FB_NEW_POOL(pool) DsqlCompilerScratch(pool, dsqlScratch->getAttachment(),
				dsqlScratch->getTransaction(), itemStatement);

		itemScratch->ddlSchema = name.schema;
		itemScratch->clientDialect = dsqlScratch->clientDialect;
		itemScratch->flags |= DsqlCompilerScratch::FLAG_DDL;
		itemScratch->package = name;

		if (itemScratch->clientDialect > SQL_DIALECT_V5)
			itemStatement->setBlrVersion(5);
		else
			itemStatement->setBlrVersion(4);

		ddlNode->dsqlPass(itemScratch);
	}

	return DdlNode::dsqlPass(dsqlScratch);
}


void CreateAlterPackageNode::checkPermission(thread_db* tdbb, jrd_tra* transaction)
{
	if (alter)
	{
		if (SCL_check_package(tdbb, name, SCL_alter) || !create)
			return;
	}

	SCL_check_create_access(tdbb, obj_packages, name.schema);
}


void CreateAlterPackageNode::execute(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch,
	jrd_tra* transaction)
{
	fb_assert(create || alter);

	//Database* dbb = tdbb->getDatabase();

	//dbb->checkOdsForDsql(ODS_12_0);

	// run all statements under savepoint control
	AutoSavePoint savePoint(tdbb, transaction);

	const bool alterIndividualParameters = (!create && alter && !items);

	if (alter)
	{
		if (alterIndividualParameters)
		{
			if (!executeAlterIndividualParameters(tdbb, dsqlScratch, transaction))
				status_exception::raise(
					Arg::Gds(isc_no_meta_update) <<
					Arg::Gds(isc_dyn_package_not_found) << name.toQuotedString());
		}
		else if (!executeAlter(tdbb, dsqlScratch, transaction))
		{
			if (create)	// create or alter
				executeCreate(tdbb, dsqlScratch, transaction);
			else
			{
				status_exception::raise(
					Arg::Gds(isc_no_meta_update) <<
					Arg::Gds(isc_dyn_package_not_found) << name.toQuotedString());
			}
		}

		dsc schemaDesc, nameDesc;
		schemaDesc.makeText(name.schema.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.schema.c_str()));
		nameDesc.makeText(name.object.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.object.c_str()));
		DFW_post_work(transaction, dfw_modify_package_header, &nameDesc, &schemaDesc, 0);
	}
	else
		executeCreate(tdbb, dsqlScratch, transaction);

	savePoint.release();	// everything is ok
}


void CreateAlterPackageNode::executeCreate(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch,
	jrd_tra* transaction)
{
	Attachment* const attachment = transaction->getAttachment();
	const MetaString& ownerName = attachment->getEffectiveUserName();

	if (createIfNotExistsOnly && !DYN_UTIL_check_unique_name_nothrow(tdbb, name, obj_package_header))
		return;

	executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_BEFORE, DDL_TRIGGER_CREATE_PACKAGE, name, {});

	DYN_UTIL_check_unique_name(tdbb, name, obj_package_header);

	static const CachedRequestId requestId;
	AutoCacheRequest requestHandle(tdbb, drq_s_pkg, DYN_REQUESTS);

	STORE (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PKG IN RDB$PACKAGES USING
	{
		PKG.RDB$SCHEMA_NAME.NULL = FALSE;
		strcpy(PKG.RDB$SCHEMA_NAME, name.schema.c_str());

		PKG.RDB$PACKAGE_NAME.NULL = FALSE;
		strcpy(PKG.RDB$PACKAGE_NAME, name.object.c_str());

		PKG.RDB$SYSTEM_FLAG.NULL = FALSE;
		PKG.RDB$SYSTEM_FLAG = 0;

		PKG.RDB$OWNER_NAME.NULL = FALSE;
		strcpy(PKG.RDB$OWNER_NAME, ownerName.c_str());

		PKG.RDB$PACKAGE_HEADER_SOURCE.NULL = FALSE;
		attachment->storeMetaDataBlob(tdbb, transaction, &PKG.RDB$PACKAGE_HEADER_SOURCE, source);

		if (ssDefiner.has_value())
		{
			PKG.RDB$SQL_SECURITY.NULL = FALSE;
			PKG.RDB$SQL_SECURITY = ssDefiner.value() == SqlSecurity::SS_DEFINER ? FB_TRUE : FB_FALSE;
		}
		else
			PKG.RDB$SQL_SECURITY.NULL = TRUE;
	}
	END_STORE

	storePrivileges(tdbb, transaction, name, obj_package_header, EXEC_PRIVILEGES);

	owner = ownerName;

	executeItems(tdbb, dsqlScratch, transaction);

	executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_AFTER, DDL_TRIGGER_CREATE_PACKAGE, name, {});
}


bool CreateAlterPackageNode::executeAlter(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch,
	jrd_tra* transaction)
{
	MemoryPool& pool = dsqlScratch->getPool();
	Attachment* attachment = transaction->getAttachment();

	static const CachedRequestId requestId;
	AutoCacheRequest requestHandle(tdbb, drq_m_pkg, DYN_REQUESTS);
	bool modified = false;

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PKG IN RDB$PACKAGES
		WITH PKG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 PKG.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		modified = true;

		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_BEFORE, DDL_TRIGGER_ALTER_PACKAGE, name, {});

		PackageItemsHolder existingItems(pool);
		existingItems.collectPackagedItems(tdbb, transaction, name, false, false);

		dropMissingItems<DropFunctionNode>(tdbb, dsqlScratch, name, existingItems.functions, functionNames);
		dropMissingItems<DropProcedureNode>(tdbb, dsqlScratch, name, existingItems.procedures, procedureNames);

		// To admit type/value change, all the constants should be recreated
		Constant::dropAllFromPackage(tdbb, transaction, name, false);

		MODIFY PKG
			PKG.RDB$PACKAGE_HEADER_SOURCE.NULL = FALSE;
			attachment->storeMetaDataBlob(tdbb, transaction, &PKG.RDB$PACKAGE_HEADER_SOURCE,
				source);

			if (!PKG.RDB$VALID_BODY_FLAG.NULL)
				PKG.RDB$VALID_BODY_FLAG = FALSE;

			if (ssDefiner.has_value())
			{
				PKG.RDB$SQL_SECURITY.NULL = FALSE;
				PKG.RDB$SQL_SECURITY = ssDefiner.value() == SqlSecurity::SS_DEFINER ? FB_TRUE : FB_FALSE;
			}
			else
				PKG.RDB$SQL_SECURITY.NULL = TRUE;
		END_MODIFY

		owner = PKG.RDB$OWNER_NAME;

		dsc schemaDesc, nameDesc;
		schemaDesc.makeText(name.schema.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.schema.c_str()));
		nameDesc.makeText(name.object.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.object.c_str()));
		DFW_post_work(transaction, dfw_drop_package_body, &nameDesc, &schemaDesc, 0);
	}
	END_FOR

	if (modified)
	{
		executeItems(tdbb, dsqlScratch, transaction);

		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_AFTER, DDL_TRIGGER_ALTER_PACKAGE, name, {});
	}

	return modified;
}


bool CreateAlterPackageNode::executeAlterIndividualParameters(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, jrd_tra* transaction)
{
	static const CachedRequestId requestId;
	AutoCacheRequest requestHandle(tdbb, drq_m_prm_pkg, DYN_REQUESTS);
	bool modified = false;

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PKG IN RDB$PACKAGES
		WITH PKG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 PKG.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		modified = true;

		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_BEFORE, DDL_TRIGGER_ALTER_PACKAGE, name, {});

		MODIFY PKG
			if (ssDefiner.has_value())
			{
				if (ssDefiner.value() != SqlSecurity::SS_DROP)
				{
					PKG.RDB$SQL_SECURITY.NULL = FALSE;
					PKG.RDB$SQL_SECURITY = ssDefiner.value() == SqlSecurity::SS_DEFINER ? FB_TRUE : FB_FALSE;
				}
				else
					PKG.RDB$SQL_SECURITY.NULL = TRUE;
			}
		END_MODIFY
	}
	END_FOR

	if (modified)
		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_AFTER, DDL_TRIGGER_ALTER_PACKAGE, name, {});

	return modified;
}

void CreateAlterPackageNode::executeItems(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch,
	jrd_tra* transaction)
{
	for (unsigned i = 0; i < items->getCount(); ++i)
	{
		switch ((*items)[i].type)
		{
			case PackageItemType::FUNCTION:
				(*items)[i].function->packageOwner = owner;
				(*items)[i].function->executeDdl(tdbb, (*items)[i].dsqlScratch, transaction, true);
				break;

			case PackageItemType::PROCEDURE:
				(*items)[i].procedure->packageOwner = owner;
				(*items)[i].procedure->executeDdl(tdbb, (*items)[i].dsqlScratch, transaction, true);
				break;
			case PackageItemType::CONSTANT:
				(*items)[i].constant->executeDdl(tdbb, (*items)[i].dsqlScratch, transaction, true);
				break;
		}
	}
}


//----------------------


string DropPackageNode::internalPrint(NodePrinter& printer) const
{
	DdlNode::internalPrint(printer);

	NODE_PRINT(printer, name);
	NODE_PRINT(printer, silent);

	return "DropPackageNode";
}


void DropPackageNode::checkPermission(thread_db* tdbb, jrd_tra* transaction)
{
	SCL_check_package(tdbb, name, SCL_drop);
}


void DropPackageNode::execute(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, jrd_tra* transaction)
{
	MemoryPool& pool = dsqlScratch->getPool();

	// run all statements under savepoint control
	AutoSavePoint savePoint(tdbb, transaction);

	bool found = false;

	static const CachedRequestId requestId;
	AutoCacheRequest requestHandle(tdbb, drq_e_pkg, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PKG IN RDB$PACKAGES
		WITH PKG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 PKG.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		found = true;

		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_BEFORE, DDL_TRIGGER_DROP_PACKAGE, name, {});

		ERASE PKG;

		if (!PKG.RDB$SECURITY_CLASS.NULL)
			deleteSecurityClass(tdbb, transaction, PKG.RDB$SECURITY_CLASS);

		dsc schemaDesc, nameDesc;
		schemaDesc.makeText(name.schema.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.schema.c_str()));
		nameDesc.makeText(name.object.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.object.c_str()));
		DFW_post_work(transaction, dfw_drop_package_header, &nameDesc, &schemaDesc, 0);
	}
	END_FOR

	if (!found && !silent)
	{
		status_exception::raise(
			Arg::Gds(isc_no_meta_update) <<
			Arg::Gds(isc_dyn_package_not_found) << name.toQuotedString());
	}

	PackageItemsHolder existingItems(pool);
	existingItems.collectPackagedItems(tdbb, transaction, name, false, true);
	existingItems.drop(tdbb, dsqlScratch, name);

	requestHandle.reset(tdbb, drq_e_pkg_prv, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PRIV IN RDB$USER_PRIVILEGES
		WITH ((PRIV.RDB$RELATION_SCHEMA_NAME EQ name.schema.c_str() AND
			   PRIV.RDB$RELATION_NAME EQ name.object.c_str() AND
			   PRIV.RDB$OBJECT_TYPE = obj_package_header) OR
			 (PRIV.RDB$USER_SCHEMA_NAME EQ name.schema.c_str() AND
			  PRIV.RDB$USER EQ name.object.c_str() AND
			  PRIV.RDB$USER_TYPE = obj_package_header)) AND
			 PRIV.RDB$GRANTOR NOT MISSING
	{
		ERASE PRIV;
	}
	END_FOR

	if (found)
		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_AFTER, DDL_TRIGGER_DROP_PACKAGE, name, {});

	savePoint.release();	// everything is ok
}


//----------------------


string CreatePackageBodyNode::internalPrint(NodePrinter& printer) const
{
	DdlNode::internalPrint(printer);

	NODE_PRINT(printer, name);
	NODE_PRINT(printer, source);
	//// FIXME-PRINT: NODE_PRINT(printer, declaredItems);
	//// FIXME-PRINT: NODE_PRINT(printer, items);

	return "CreatePackageBodyNode";
}


DdlNode* CreatePackageBodyNode::dsqlPass(DsqlCompilerScratch* dsqlScratch)
{
	dsqlScratch->qualifyExistingName(name, obj_package_header);
	protectSystemSchema(name.schema, obj_package_header);
	dsqlScratch->ddlSchema = name.schema;

	MemoryPool& pool = dsqlScratch->getPool();

	source.ltrim("\n\r\t ");

	// process declaredItems and items
	Array<CreateAlterPackageNode::Item>* arrays[] = {declaredItems, items};
	PackageItemsHolder names[FB_NELEM(arrays)];

	for (unsigned i = 0; i < FB_NELEM(arrays); ++i)
	{
		if (!arrays[i])
			continue;

		for (unsigned j = 0; j < arrays[i]->getCount(); ++j)
		{
			DdlNode* ddlNode;

			switch ((*arrays[i])[j].type)
			{
				case PackageItemType::FUNCTION:
				{
					CreateAlterFunctionNode* const fun = (*arrays[i])[j].function;
					ddlNode = fun;
					names[i].functions.addName<PackageItemType::FUNCTION>(fun->name);

					fun->name.schema = name.schema;
					fun->name.package = name.object;
					fun->create = true;

					if (arrays[i] == items)
						fun->alter = true;

					break;
				}

				case PackageItemType::PROCEDURE:
				{
					CreateAlterProcedureNode* const proc = (*arrays[i])[j].procedure;
					ddlNode = proc;
					names[i].procedures.addName<PackageItemType::PROCEDURE>(proc->name);

					proc->name.schema = name.schema;
					proc->name.package = name.object;
					proc->create = true;

					if (arrays[i] == items)
						proc->alter = true;

					break;
				}
				case PackageItemType::CONSTANT:
				{
					CreatePackageConstantNode* const constant = (*arrays[i])[j].constant;
					ddlNode = constant;

					names[i].constants.addName<PackageItemType::CONSTANT>(constant->name);

					constant->name.schema = name.schema;
					constant->name.package = name.object;
					constant->create = true;
					constant->makePrivate();
					break;
				}
				default:
					fb_assert(false);
			}

			auto itemStatement = FB_NEW_POOL(pool) DsqlDdlStatement(pool, dsqlScratch->getAttachment(), ddlNode);

			auto itemScratch = (*arrays[i])[j].dsqlScratch =
				FB_NEW_POOL(pool) DsqlCompilerScratch(pool, dsqlScratch->getAttachment(),
					dsqlScratch->getTransaction(), itemStatement);

			itemScratch->ddlSchema = name.schema;
			itemScratch->clientDialect = dsqlScratch->clientDialect;
			itemScratch->flags |= DsqlCompilerScratch::FLAG_DDL;
			itemScratch->package = name;

			if (itemScratch->clientDialect > SQL_DIALECT_V5)
				itemStatement->setBlrVersion(5);
			else
				itemStatement->setBlrVersion(4);

			ddlNode->dsqlPass(itemScratch);
		}
	}

	return DdlNode::dsqlPass(dsqlScratch);
}


void CreatePackageBodyNode::checkPermission(thread_db* tdbb, jrd_tra* transaction)
{
	SCL_check_create_access(tdbb, obj_packages, name.schema);
}


void CreatePackageBodyNode::execute(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch, jrd_tra* transaction)
{
	MemoryPool& pool = dsqlScratch->getPool();
	Attachment* attachment = transaction->getAttachment();

	// run all statements under savepoint control
	AutoSavePoint savePoint(tdbb, transaction);

	static const CachedRequestId requestId;
	AutoCacheRequest requestHandle(tdbb, drq_m_pkg_body, DYN_REQUESTS);
	bool modified = false;

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PKG IN RDB$PACKAGES
		WITH PKG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 PKG.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		if (!PKG.RDB$VALID_BODY_FLAG.NULL && PKG.RDB$VALID_BODY_FLAG != 0)
		{
			if (createIfNotExistsOnly)
				return;

			status_exception::raise(
				Arg::Gds(isc_no_meta_update) <<
				Arg::Gds(isc_dyn_package_body_exists) << name.toQuotedString());
		}

		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_BEFORE, DDL_TRIGGER_CREATE_PACKAGE_BODY, name, {});

		MODIFY PKG
			PKG.RDB$VALID_BODY_FLAG.NULL = FALSE;
			PKG.RDB$VALID_BODY_FLAG = TRUE;

			PKG.RDB$PACKAGE_BODY_SOURCE.NULL = FALSE;
			attachment->storeMetaDataBlob(tdbb, transaction, &PKG.RDB$PACKAGE_BODY_SOURCE, source);
		END_MODIFY

		modified = true;

		owner = PKG.RDB$OWNER_NAME;
	}
	END_FOR

	if (!modified)
	{
		status_exception::raise(
			Arg::Gds(isc_no_meta_update) <<
			Arg::Gds(isc_dyn_package_not_found) << name.toQuotedString());
	}

	PackageItemsHolder headerItems(pool);
	headerItems.collectPackagedItems(tdbb, transaction, name, false, true);

	PackageItemsHolder existingItems(pool);

	// process declaredItems and items
	Array<CreateAlterPackageNode::Item>* arrays[] = {declaredItems, items};

	for (unsigned i = 0; i < FB_NELEM(arrays); ++i)
	{
		if (!arrays[i])
			continue;

		if (arrays[i] == items)
		{
			existingItems.clear();
		}

		existingItems.collectPackagedItems(tdbb, transaction, name, true, true);

		for (unsigned j = 0; j < arrays[i]->getCount(); ++j)
		{
			CreateAlterPackageNode::Item& elem = (*arrays[i])[j];

			switch (elem.type)
			{
				case PackageItemType::FUNCTION:
				{
					CreateAlterFunctionNode* func = elem.function;

					if (arrays[i] == items)
						func->privateScope = !headerItems.functions.exist(Signature(func->name.object));
					else
					{
						existingItems.functions.checkDuplicate<PackageItemType::FUNCTION>(func->name);
					}

					func->packageOwner = owner;
					func->preserveDefaults =
						existingItems.functions.exist(Signature(func->name.object)) && arrays[i] == items;
					func->executeDdl(tdbb, elem.dsqlScratch, transaction, true);
					break;
				}

				case PackageItemType::PROCEDURE:
				{
					CreateAlterProcedureNode* proc = elem.procedure;

					if (arrays[i] == items)
						proc->privateScope = !headerItems.procedures.exist(Signature(proc->name.object));
					else
					{
						existingItems.procedures.checkDuplicate<PackageItemType::PROCEDURE>(proc->name);
					}

					proc->packageOwner = owner;
					proc->preserveDefaults =
						existingItems.procedures.exist(Signature(proc->name.object)) && arrays[i] == items;
					proc->executeDdl(tdbb, elem.dsqlScratch, transaction, true);
					break;
				}
				case PackageItemType::CONSTANT:
				{
					CreatePackageConstantNode* constant = elem.constant;

					headerItems.constants.checkDuplicate<PackageItemType::CONSTANT>(constant->name);
					existingItems.constants.checkDuplicate<PackageItemType::CONSTANT>(constant->name);

					constant->executeDdl(tdbb, elem.dsqlScratch, transaction, true);
					break;
				}
			}
		}
	}

	PackageItemsHolder newItems(pool);
	newItems.collectPackagedItems(tdbb, transaction, name, true, false);
	existingItems.checkDefineMatch(pool, name, newItems);


	executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_AFTER, DDL_TRIGGER_CREATE_PACKAGE_BODY, name, {});

	savePoint.release();	// everything is ok
}


//----------------------


string DropPackageBodyNode::internalPrint(NodePrinter& printer) const
{
	DdlNode::internalPrint(printer);

	NODE_PRINT(printer, name);
	NODE_PRINT(printer, silent);

	return "DropPackageBodyNode";
}


void DropPackageBodyNode::checkPermission(thread_db* tdbb, jrd_tra* transaction)
{
	SCL_check_package(tdbb, name, SCL_drop);
}


void DropPackageBodyNode::execute(thread_db* tdbb, DsqlCompilerScratch* dsqlScratch,
	jrd_tra* transaction)
{
	MemoryPool& pool = dsqlScratch->getPool();

	// run all statements under savepoint control
	AutoSavePoint savePoint(tdbb, transaction);

	bool found = false;

	static const CachedRequestId requestId;
	AutoCacheRequest requestHandle(tdbb, drq_m_pkg_body2, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PKG IN RDB$PACKAGES
		WITH PKG.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 PKG.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		found = true;

		executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_BEFORE, DDL_TRIGGER_DROP_PACKAGE_BODY, name, {});

		MODIFY PKG
			PKG.RDB$VALID_BODY_FLAG.NULL = TRUE;
			PKG.RDB$PACKAGE_BODY_SOURCE.NULL = TRUE;

			dsc schemaDesc, nameDesc;
			schemaDesc.makeText(name.schema.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.schema.c_str()));
			nameDesc.makeText(name.object.length(), ttype_metadata, (UCHAR*) const_cast<char*>(name.object.c_str()));
			DFW_post_work(transaction, dfw_drop_package_body, &nameDesc, &schemaDesc, 0);
		END_MODIFY
	}
	END_FOR

	if (!found)
	{
		if (silent)
		{
			savePoint.release();
			return;
		}

		status_exception::raise(
			Arg::Gds(isc_no_meta_update) <<
			Arg::Gds(isc_dyn_package_not_found) << name.toQuotedString());
	}

	requestHandle.reset(tdbb, drq_m_pkg_fun, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		FUN IN RDB$FUNCTIONS
		WITH FUN.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 FUN.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		if (!FUN.RDB$PRIVATE_FLAG.NULL && FUN.RDB$PRIVATE_FLAG != 0)
		{
			dropItem<DropFunctionNode>(tdbb, dsqlScratch, QualifiedName(FUN.RDB$FUNCTION_NAME, name.schema, name.object));
		}
		else
		{
			MODIFY FUN
				FUN.RDB$FUNCTION_TYPE.NULL = TRUE;
				FUN.RDB$FUNCTION_BLR.NULL = TRUE;
				FUN.RDB$DEBUG_INFO.NULL = TRUE;
				FUN.RDB$MODULE_NAME.NULL = TRUE;
				FUN.RDB$ENGINE_NAME.NULL = TRUE;
				FUN.RDB$ENTRYPOINT.NULL = TRUE;
			END_MODIFY
		}
	}
	END_FOR

	requestHandle.reset(tdbb, drq_m_pkg_prc, DYN_REQUESTS);

	FOR (REQUEST_HANDLE requestHandle TRANSACTION_HANDLE transaction)
		PRC IN RDB$PROCEDURES
		WITH PRC.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			 PRC.RDB$PACKAGE_NAME EQ name.object.c_str()
	{
		if (!PRC.RDB$PRIVATE_FLAG.NULL && PRC.RDB$PRIVATE_FLAG != 0)
		{
			dropItem<DropProcedureNode>(tdbb, dsqlScratch, QualifiedName(PRC.RDB$PROCEDURE_NAME, name.schema, name.object));
		}
		else
		{
			MODIFY PRC
				PRC.RDB$PROCEDURE_TYPE.NULL = TRUE;
				PRC.RDB$PROCEDURE_BLR.NULL = TRUE;
				PRC.RDB$DEBUG_INFO.NULL = TRUE;
				PRC.RDB$ENGINE_NAME.NULL = TRUE;
				PRC.RDB$ENTRYPOINT.NULL = TRUE;
			END_MODIFY
		}
	}
	END_FOR

	Constant::dropAllFromPackage(tdbb, transaction, name, true);

	executeDdlTrigger(tdbb, dsqlScratch, transaction, DTW_AFTER, DDL_TRIGGER_DROP_PACKAGE_BODY, name, {});

	savePoint.release();	// everything is ok
}


}	// namespace Jrd
