/*
 *	PROGRAM:	JRD Access Method
 *	MODULE:		met.epp
 *	DESCRIPTION:	Meta data handler
 *
 * The contents of this file are subject to the Interbase Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.Inprise.com/IPL.html
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code was created by Inprise Corporation
 * and its predecessors. Portions created by Inprise Corporation are
 * Copyright (C) Inprise Corporation.
 *
 * All Rights Reserved.
 * Contributor(s): ______________________________________.
 *
 * 2001.6.25 Claudio Valderrama: Finish MET_lookup_generator_id() by
 *	assigning it a number in the compiled requests table.
 *
 * 2001.07.06 Sean Leyne - Code Cleanup, removed "#ifdef READONLY_DATABASE"
 *                         conditionals, as the engine now fully supports
 *                         readonly databases.
 * 2001.10.03 Claudio Valderrama: MET_relation_owns_trigger() determines if
 *   there's a row in rdb$triggers with the given relation's and trigger's names.
 * 2001.10.04 Claudio Valderrama: MET_relation_default_class() determines if the
 *   given security class name is the default security class for a relation.
 *   Modify MET_lookup_field() so it can verify the field's security class, too.
 * 2002-02-24 Sean Leyne - Code Cleanup of old Win 3.1 port (WINDOWS_ONLY)
 * 2002-09-16 Nickolay Samofatov - Deferred trigger compilation changes
 * 2002.10.29 Sean Leyne - Removed obsolete "Netware" port
 * 2004.01.16 Vlad Horsun: added support for default parameters
 */

#include "firebird.h"
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "../jrd/jrd.h"
#include "../jrd/val.h"
#include "../jrd/irq.h"
#include "../jrd/tra.h"
#include "../jrd/lck.h"
#include "../jrd/ods.h"
#include "../jrd/btr.h"
#include "../jrd/req.h"
#include "../jrd/Statement.h"
#include "../jrd/exe.h"
#include "../jrd/scl.h"
#include "../jrd/blb.h"
#include "../jrd/met.h"
#include "../jrd/os/pio.h"
#include "../jrd/sdw.h"
#include "../jrd/flags.h"
#include "../jrd/lls.h"
#include "../jrd/intl.h"
#include "../jrd/align.h"
#include "../jrd/flu.h"
#include "../jrd/blob_filter.h"
#include "../dsql/StmtNodes.h"
#include "../intl/charsets.h"
#include "../common/gdsassert.h"
#include "../jrd/blb_proto.h"
#include "../jrd/cmp_proto.h"
#include "../jrd/dfw_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/err_proto.h"
#include "../jrd/evl_proto.h"
#include "../jrd/exe_proto.h"
#include "../jrd/ext_proto.h"
#include "../jrd/flu_proto.h"
#include "../yvalve/gds_proto.h"
#include "../jrd/idx_proto.h"
#include "../jrd/ini_proto.h"

#include "../jrd/lck.h"
#include "../jrd/met_proto.h"
#include "../jrd/mov_proto.h"
#include "../jrd/par_proto.h"
#include "../jrd/os/pio_proto.h"
#include "../jrd/scl_proto.h"
#include "../jrd/sdw_proto.h"
#include "../jrd/tra_proto.h"
#include "../jrd/intl_proto.h"
#include "../common/utils_proto.h"

#include "../jrd/PreparedStatement.h"
#include "../jrd/RecordSourceNodes.h"
#include "../jrd/DebugInterface.h"
#include "../common/classes/Hash.h"
#include "../common/classes/MsgPrint.h"
#include "../jrd/Function.h"
#include "../jrd/trace/TraceJrdHelpers.h"


#ifdef HAVE_CTYPE_H
#include <ctype.h>
#endif

// Pick up relation ids
#include "../jrd/ini.h"

DATABASE DB = FILENAME "ODS.RDB";

using namespace Jrd;
using namespace Firebird;

static ULONG get_rel_flags_from_FLAGS(USHORT);
static void get_trigger(thread_db*, jrd_rel*, bid*, bid*, Triggers&, const TEXT*, FB_UINT64,
	USHORT, const MetaName&, const string&, const bid*, TriState ssDefiner);
static void lookup_view_contexts(thread_db*, jrd_rel*);
static void make_relation_scope_name(const TEXT*, const USHORT, string& str);
static ValueExprNode* parse_field_default_blr(thread_db* tdbb, bid* blob_id);
static BoolExprNode* parse_field_validation_blr(thread_db* tdbb, bid* blob_id, const MetaName name);
static void save_trigger_data(thread_db*, Triggers&, jrd_rel*, Statement*, blb*, blb*,
	const TEXT*, FB_UINT64, USHORT, const MetaName&, const string&,
	const bid*, TriState ssDefiner);
static bool verify_TRG_ignore_perm(thread_db*, const MetaName&);


void MET_get_domain(thread_db* tdbb, MemoryPool& csbPool, const MetaName& name, dsc* desc,
	FieldInfo* fieldInfo)
{
/**************************************
 *
 *	M E T _ g e t _ d o m a i n
 *
 **************************************
 *
 * Functional description
 *      Get domain descriptor and informations.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	bool found = false;

	AutoCacheRequest handle(tdbb, irq_l_domain, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle)
		FLD IN RDB$FIELDS WITH FLD.RDB$FIELD_NAME EQ name.c_str()
	{
		if (DSC_make_descriptor(desc,
								FLD.RDB$FIELD_TYPE,
								FLD.RDB$FIELD_SCALE,
								FLD.RDB$FIELD_LENGTH,
								FLD.RDB$FIELD_SUB_TYPE,
								CSetId(FLD.RDB$CHARACTER_SET_ID),
								CollId(FLD.RDB$COLLATION_ID)))
		{
			found = true;

			if (fieldInfo)
			{
				fieldInfo->nullable = FLD.RDB$NULL_FLAG.NULL || FLD.RDB$NULL_FLAG == 0;

				Jrd::ContextPoolHolder context(tdbb, &csbPool);

				if (FLD.RDB$DEFAULT_VALUE.NULL)
					fieldInfo->defaultValue = NULL;
				else
					fieldInfo->defaultValue = parse_field_default_blr(tdbb, &FLD.RDB$DEFAULT_VALUE);

				if (FLD.RDB$VALIDATION_BLR.NULL)
					fieldInfo->validationExpr = NULL;
				else
				{
					fieldInfo->validationExpr = parse_field_validation_blr(tdbb,
						&FLD.RDB$VALIDATION_BLR, name);
				}
			}
		}
	}
	END_FOR

	if (!found)
	{
		ERR_post(Arg::Gds(isc_domnotdef) << Arg::Str(name));
	}
}


MetaName MET_get_relation_field(thread_db* tdbb, MemoryPool& csbPool, const MetaName& relationName,
	const MetaName& fieldName, dsc* desc, FieldInfo* fieldInfo)
{
/**************************************
 *
 *	M E T _ g e t _ r e l a t i o n _ f i e l d
 *
 **************************************
 *
 * Functional description
 *  Get relation field descriptor and informations.
 *  Returns field source name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	bool found = false;
	MetaName sourceName;

	AutoCacheRequest handle(tdbb, irq_l_relfield, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE handle)
		RFL IN RDB$RELATION_FIELDS CROSS
		FLD IN RDB$FIELDS WITH
			RFL.RDB$RELATION_NAME EQ relationName.c_str() AND
			RFL.RDB$FIELD_NAME EQ fieldName.c_str() AND
			FLD.RDB$FIELD_NAME EQ RFL.RDB$FIELD_SOURCE
	{
		if (DSC_make_descriptor(desc,
								FLD.RDB$FIELD_TYPE,
								FLD.RDB$FIELD_SCALE,
								FLD.RDB$FIELD_LENGTH,
								FLD.RDB$FIELD_SUB_TYPE,
								CSetId(FLD.RDB$CHARACTER_SET_ID),
								CollId(RFL.RDB$COLLATION_ID.NULL ? FLD.RDB$COLLATION_ID : RFL.RDB$COLLATION_ID)))
		{
			found = true;
			sourceName = RFL.RDB$FIELD_SOURCE;

			if (fieldInfo)
			{
				fieldInfo->nullable = RFL.RDB$NULL_FLAG.NULL ?
					(FLD.RDB$NULL_FLAG.NULL || FLD.RDB$NULL_FLAG == 0) : RFL.RDB$NULL_FLAG == 0;

				Jrd::ContextPoolHolder context(tdbb, &csbPool);
				bid* defaultId = NULL;

				if (!RFL.RDB$DEFAULT_VALUE.NULL)
					defaultId = &RFL.RDB$DEFAULT_VALUE;
				else if (!FLD.RDB$DEFAULT_VALUE.NULL)
					defaultId = &FLD.RDB$DEFAULT_VALUE;

				if (defaultId)
					fieldInfo->defaultValue = parse_field_default_blr(tdbb, defaultId);
				else
					fieldInfo->defaultValue = NULL;

				if (FLD.RDB$VALIDATION_BLR.NULL)
					fieldInfo->validationExpr = NULL;
				else
				{
					fieldInfo->validationExpr = parse_field_validation_blr(tdbb,
						&FLD.RDB$VALIDATION_BLR, RFL.RDB$FIELD_SOURCE);
				}
			}
		}
	}
	END_FOR

	if (!found)
	{
		ERR_post(Arg::Gds(isc_dyn_column_does_not_exist) << Arg::Str(fieldName) <<
															Arg::Str(relationName));
	}

	return sourceName;
}


void MetadataCache::update_partners(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ u p d a t e _ p a r t n e r s
 *
 **************************************
 *
 * Functional description
 *      Mark all relations to update their links to FK partners
 *      Called when any index is deleted because engine don't know
 *      was it used in any FK or not
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* const dbb = tdbb->getDatabase();

	for (auto relation : dbb->dbb_mdc->mdc_relations)
	{
		if (!relation)
			continue;

		relation->checkPartners(tdbb);
	}
}


#ifdef NEVERDEF
void MetadataCache::verify_cache(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ v e r i f y _ c a c h e
 *
 **************************************
 *
 * Functional description
 *      Check if all links between routines are properly counted
 *
 **************************************/
	SET_TDBB(tdbb);
	Database* dbb = tdbb->getDatabase();
	if (!dbb)
		return;

	MetadataCache* mdc = dbb->dbb_mdc;
	MutexLockGuard guard(mdc->mdc_use_mutex, FB_FUNCTION);

	// Walk procedures and calculate internal dependencies
	for (auto routine : mdc->mdc_procedures)
	{
		if (routine && routine->getStatement() /*&&
			!(routine->flags & Routine::FLAG_OBSOLETE)*/ )
		{
			inc_int_use_count(routine->getStatement());
		}
	}

	for (auto routine : mdc->mdc_functions)
	{
		if (routine && routine->getStatement() /*&&
			!(routine->flags & Routine::FLAG_OBSOLETE)*/ )
		{
			inc_int_use_count(routine->getStatement());
		}
	}

	// Walk procedures again and check dependencies
	for (auto routine : mdc->mdc_procedures)
	{
		if (routine && routine->getStatement() && /*
			 !(routine->flags & Routine::FLAG_OBSOLETE) && */
			 routine->getUseCount() < routine->intUseCount)
		{
			string buffer;
			buffer.printf("Procedure %d:%s is not properly counted (use count=%d, prc use=%d). Used by: \n",
				routine->getId(), routine->c_name(),
				routine->getUseCount(), routine->intUseCount);

			for (auto routine2 : mdc->mdc_procedures)
			{
				if (routine2 && routine2->getStatement() /*&& !(routine2->flags & Routine::FLAG_OBSOLETE)*/ )
				{
					// Loop over procedures from resource list of request
					for (auto resource : routine2->getStatement()->resources.getObjects(Resource::rsc_procedure))
					{
						if (resource->rsc_routine == routine)
						{
							string buf;
							buf.printf("%d:%s\n", routine2->getId(),
								routine2->getName().toString().c_str());
							buffer += buf;
						}
					}
				}
			}

			for (auto routine2 : mdc->mdc_functions)
			{
				if (routine2 && routine2->getStatement() /*&& !(routine2->flags & Routine::FLAG_OBSOLETE)*/ )
				{
					// Loop over functions from resource list of request
					for (auto resource : routine2->getStatement()->resources.getObjects(Resource::rsc_function))
					{
						if (resource->rsc_type != Resource::rsc_procedure)
							break;

						if (resource->rsc_routine == routine)
						{
							string buf;
							buf.printf("%d:%s\n", routine2->getId(),
								routine2->getName().toString().c_str());
							buffer += buf;
						}
					}
				}
			}

			gds__log("%s", buffer.c_str());
			fb_assert(false);
		}
	}

	// Walk functions again and check dependencies
	for (auto routine : mdc->mdc_functions)
	{
		if (routine && routine->getStatement() && /*
			 !(routine->flags & Routine::FLAG_OBSOLETE) && */
			 routine->getUseCount() < routine->intUseCount)
		{
			string buffer;
			buffer.printf("Function %d:%s is not properly counted (use count=%d, func use=%d). Used by: \n",
				routine->getId(), routine->getName().toString().c_str(),
				routine->getUseCount(), routine->intUseCount);

			for (auto routine2 : mdc->mdc_procedures)
			{
				if (routine2 && routine2->getStatement() /*&& !(routine2->flags & Routine::FLAG_OBSOLETE)*/ )
				{
					// Loop over procedures from resource list of request
					for (auto resource : routine2->getStatement()->resources.getObjects(Resource::rsc_procedure))
					{
						if (resource->rsc_type != Resource::rsc_function)
							break;

						if (resource->rsc_routine == routine)
						{
							// Do not enable this code in production builds unless
							// the possible B.O. is fixed here.
							string buf;
							buf.printf("%d:%s\n", routine2->getId(),
								routine2->getName().toString().c_str());
							buffer += buf;
						}
					}
				}
			}

			for (auto routine2 : mdc->mdc_functions)
			{
				if (routine2 && routine2->getStatement() /*&& !(routine2->flags & Routine::FLAG_OBSOLETE)*/ )
				{
					// Loop over functions from resource list of request
					for (auto resource : routine2->getStatement()->resources.getObjects(Resource::rsc_function))
					{
						if (resource->rsc_type != Resource::rsc_function)
							break;

						if (resource->rsc_routine == routine)
						{
							// Do not enable this code in production builds unless
							// the possible B.O. is fixed here.
							string buf;
							buf.printf("%d:%s\n", routine2->getId(),
								routine2->getName().toString().c_str());
							buffer += buf;
						}
					}
				}
			}

			gds__log("%s", buffer);
			fb_assert(false);
		}
	}

	// Fix back int_use_count
	for (auto routine : mdc->mdc_procedures)
	{
		if (routine)
			routine->intUseCount = 0;
	}

	for (auto routine : mdc->mdc_functions)
	{
		if (routine)
			routine->intUseCount = 0;
	}
}
#endif // NEVERDEF


// Done before MDC is deleted
void MetadataCache::cleanup(thread_db* tdbb)
{
	mdc_relations.cleanup(tdbb);
	mdc_procedures.cleanup(tdbb);
	mdc_functions.cleanup(tdbb);
	mdc_charsets.cleanup(tdbb);

	for (unsigned i = 0; i < DB_TRIGGERS_COUNT; ++i)
	{
		auto* ptr = mdc_triggers[i].load(atomics::memory_order_relaxed);
		if (ptr)
		{
			Cached::Triggers::cleanup(tdbb, ptr);
			mdc_triggers[i].store(nullptr, atomics::memory_order_relaxed);
		}
	}
}


void MetadataCache::clear(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ c l e a r _ c a c h e
 *
 **************************************
 *
 * Functional description
 *      Remove all unused objects from metadata cache to
 *      release resources they use
 *
 **************************************/
/* !!!!!!!!!!!!!!!!!!! force remove old versions

	SET_TDBB(tdbb);
#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif

	Attachment* const att = tdbb->getAttachment();

	// Release global (db-level and DDL) triggers

	for (unsigned i = 0; i < DB_TRIGGERS_COUNT; i++)
		MET_release_triggers(tdbb, &att->att_triggers[i], false);

	// Release relation triggers

	vec<jrd_rel*>* const relations = att->att_relations;
	if (relations)
	{
		vec<jrd_rel*>::iterator ptr, end;
		for (ptr = relations->begin(), end = relations->end(); ptr < end; ++ptr)
		{
			jrd_rel* const relation = *ptr;
			if (!relation)
				continue;

			relation->releaseTriggers(tdbb, false);
		}
	}

	const auto walkProcFunc = [&att](std::function<void (Routine*)> func)
	{
		for (const auto routine : att->att_procedures)
		{
			if (routine)
				func(routine);
		}

		for (const auto routine : att->att_functions)
		{
			if (routine)
				func(routine);
		}
	};

	// Walk routines and calculate internal dependencies.

	walkProcFunc([](Routine* routine)
	{
		if (routine->getStatement() &&
			!(routine->flags & Routine::FLAG_OBSOLETE) )
		{
			inc_int_use_count(routine->getStatement());
		}
	});

	// Walk routines again and adjust dependencies for routines which will not be removed.

	walkProcFunc([](Routine* routine)
	{
		if (routine->getStatement() &&
			!(routine->flags & Routine::FLAG_OBSOLETE) &&
			routine->useCount != routine->intUseCount )
		{
			adjust_dependencies(routine);
		}
	});

	// Deallocate all used requests.

	walkProcFunc([&tdbb](Routine* routine)
	{
		if (routine->getStatement() && !(routine->flags & Routine::FLAG_OBSOLETE) &&
			routine->intUseCount >= 0 &&
			routine->useCount == routine->intUseCount)
		{
			routine->releaseStatement(tdbb);

			if (routine->existenceLock)
				LCK_release(tdbb, routine->existenceLock);
			routine->existenceLock = NULL;
			routine->flags |= Routine::FLAG_OBSOLETE;
		}

		// Leave it in state 0 to avoid extra pass next time to clear it
		// Note: we need to adjust intUseCount for all routines
		// in cache because any of them may have been affected from
		// dependencies earlier. Even routines that were not scanned yet !
		routine->intUseCount = 0;
	});

#ifdef DEV_BUILD
	MET_verify_cache(tdbb);
#endif

 */
}


void MET_activate_shadow(thread_db* tdbb)
{
/**************************************
 *
 *      M E T _ a c t i v a t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      Activate the current database, which presumably
 *      was formerly a shadow, by deleting all records
 *      corresponding to the shadow that this database
 *      represents.
 *      Get rid of write ahead log for the activated shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	// Erase any secondary files of the primary database of the shadow being activated.

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER EQ 0
		ERASE X;
	END_FOR

	PageSpace* pageSpace = dbb->dbb_page_manager.findPageSpace(DB_PAGE_SPACE);
	const char* dbb_file_name = pageSpace->file->fil_string;

	// go through files looking for any that expand to the current database name
	SCHAR expanded_name[MAXPATHLEN];
	AutoRequest handle2;
	handle.reset();

	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER NE 0

		PIO_expand(X.RDB$FILE_NAME, (USHORT)strlen(X.RDB$FILE_NAME),
					expanded_name, sizeof(expanded_name));

		if (!strcmp(expanded_name, dbb_file_name))
		{
			FOR(REQUEST_HANDLE handle2) Y IN RDB$FILES
				WITH X.RDB$SHADOW_NUMBER EQ Y.RDB$SHADOW_NUMBER
				MODIFY Y
					Y.RDB$SHADOW_NUMBER = 0;
				END_MODIFY
			END_FOR

			ERASE X;
		}
	END_FOR
}


ULONG MET_align(const dsc* desc, ULONG value)
{
/**************************************
 *
 *      M E T _ a l i g n
 *
 **************************************
 *
 * Functional description
 *      Align value (presumed offset) on appropriate border
 *      and return.
 *
 **************************************/
	USHORT alignment = desc->dsc_length;
	switch (desc->dsc_dtype)
	{
	case dtype_text:
	case dtype_cstring:
		return value;

	case dtype_varying:
		alignment = sizeof(USHORT);
		break;
	}

	alignment = MIN(alignment, FORMAT_ALIGNMENT);

	return FB_ALIGN(value, alignment);
}


DeferredWork* MET_change_fields(thread_db* tdbb, jrd_tra* transaction, const dsc* field_source)
{
/**************************************
 *
 *      M E T _ c h a n g e _ f i e l d s
 *
 **************************************
 *
 * Functional description
 *      Somebody is modifying RDB$FIELDS.
 *      Find all relations affected and schedule a format update.
 *      Find all procedures and triggers and schedule a BLR validate.
 *      Find all functions and schedule a BLR validate.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	dsc relation_name;
	DeferredWork* dw = NULL;
	AutoCacheRequest request(tdbb, irq_m_fields, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_FIELDS
		CROSS R IN RDB$RELATIONS
		OVER RDB$RELATION_NAME
		WITH X.RDB$FIELD_SOURCE EQ field_source->dsc_address
	{
		relation_name.makeText(sizeof(X.RDB$RELATION_NAME) - 1, CS_METADATA,
			(UCHAR*) X.RDB$RELATION_NAME);
		SCL_check_relation(tdbb, &relation_name, SCL_alter);
		{
			AutoSetRestore2<jrd_tra*, thread_db> tempTrans(tdbb,
				&thread_db::getTransaction,
				&thread_db::setTransaction,
				transaction);

			MetadataCache::tagForUpdate<Cached::Relation>(tdbb, R.RDB$RELATION_ID);
		}
		DFW_post_work(transaction, dfw_commit_relation, nullptr, R.RDB$RELATION_ID);

		AutoCacheRequest request2(tdbb, irq_m_fields4, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request2)
			DEP IN RDB$DEPENDENCIES CROSS
			PRC IN RDB$PROCEDURES
				WITH DEP.RDB$DEPENDED_ON_NAME EQ X.RDB$RELATION_NAME AND
					 DEP.RDB$FIELD_NAME EQ X.RDB$FIELD_NAME AND
					 DEP.RDB$DEPENDED_ON_TYPE EQ obj_relation AND
					 DEP.RDB$DEPENDENT_TYPE EQ obj_procedure AND
					 DEP.RDB$DEPENDENT_NAME EQ PRC.RDB$PROCEDURE_NAME AND
					 PRC.RDB$PACKAGE_NAME MISSING
		{
			MetaName proc_name(PRC.RDB$PROCEDURE_NAME);

			dsc desc;
			desc.makeText(proc_name.length(), CS_METADATA, (UCHAR*) proc_name.c_str());

			DeferredWork* dw2 =
				DFW_post_work(transaction, dfw_modify_procedure, &desc, PRC.RDB$PROCEDURE_ID);
			DFW_post_work_arg(transaction, dw2, NULL, 0, dfw_arg_check_blr);
		}
		END_FOR

		request2.reset(tdbb, irq_m_fields5, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request2)
			DEP IN RDB$DEPENDENCIES CROSS
			TRG IN RDB$TRIGGERS
				WITH DEP.RDB$DEPENDED_ON_NAME EQ X.RDB$RELATION_NAME AND
					 DEP.RDB$FIELD_NAME EQ X.RDB$FIELD_NAME AND
					 DEP.RDB$DEPENDED_ON_TYPE EQ obj_relation AND
					 DEP.RDB$DEPENDENT_TYPE EQ obj_trigger AND
					 DEP.RDB$DEPENDENT_NAME EQ TRG.RDB$TRIGGER_NAME
		{
			MetaName trigger_name(TRG.RDB$TRIGGER_NAME);
			MetaName relation_name(TRG.RDB$RELATION_NAME);

			dsc desc;
			desc.makeText(trigger_name.length(), CS_METADATA, (UCHAR*) trigger_name.c_str());

			DeferredWork* dw2 =
				DFW_post_work(transaction, dfw_modify_trigger, &desc, TRG.RDB$TRIGGER_TYPE);

			desc.makeText(relation_name.length(), CS_METADATA, (UCHAR*) relation_name.c_str());
			DFW_post_work_arg(transaction, dw2, &desc, 0, dfw_arg_check_blr);
		}
		END_FOR

		request2.reset(tdbb, irq_m_fields8, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request2)
			DEP IN RDB$DEPENDENCIES CROSS
			FUN IN RDB$FUNCTIONS
				WITH DEP.RDB$DEPENDED_ON_NAME EQ X.RDB$RELATION_NAME AND
					 DEP.RDB$FIELD_NAME EQ X.RDB$FIELD_NAME AND
					 DEP.RDB$DEPENDED_ON_TYPE EQ obj_relation AND
					 DEP.RDB$DEPENDENT_TYPE EQ obj_udf AND
					 DEP.RDB$DEPENDENT_NAME EQ FUN.RDB$FUNCTION_NAME AND
					 FUN.RDB$PACKAGE_NAME MISSING
		{
			MetaName name(FUN.RDB$FUNCTION_NAME);

			dsc desc;
			desc.makeText(name.length(), CS_METADATA, (UCHAR*) name.c_str());

			DeferredWork* dw2 =
				DFW_post_work(transaction, dfw_modify_function, &desc, FUN.RDB$FUNCTION_ID);
			DFW_post_work_arg(transaction, dw2, NULL, 0, dfw_arg_check_blr);
		}
		END_FOR
	}
	END_FOR

	request.reset(tdbb, irq_m_fields2, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		PRC IN RDB$PROCEDURES
			WITH DEP.RDB$DEPENDED_ON_NAME EQ field_source->dsc_address AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_procedure AND
				 DEP.RDB$DEPENDENT_NAME EQ PRC.RDB$PROCEDURE_NAME AND
				 PRC.RDB$PACKAGE_NAME MISSING
	{
		MetaName proc_name(PRC.RDB$PROCEDURE_NAME);

		dsc desc;
		desc.makeText(proc_name.length(), CS_METADATA, (UCHAR*) proc_name.c_str());

		DeferredWork* dw2 =
			DFW_post_work(transaction, dfw_modify_procedure, &desc, PRC.RDB$PROCEDURE_ID);
		DFW_post_work_arg(transaction, dw2, NULL, 0, dfw_arg_check_blr);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields6, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		PRC IN RDB$PROCEDURES
			WITH DEP.RDB$DEPENDED_ON_NAME EQ field_source->dsc_address AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
				 (DEP.RDB$DEPENDENT_TYPE EQ obj_package_header OR
				 	DEP.RDB$DEPENDENT_TYPE EQ obj_package_body) AND
				 DEP.RDB$DEPENDENT_NAME EQ PRC.RDB$PACKAGE_NAME
	{
		MetaName proc_name(PRC.RDB$PROCEDURE_NAME);

		dsc desc;
		desc.makeText(proc_name.length(), CS_METADATA, (UCHAR*) proc_name.c_str());

		DeferredWork* dw2 = DFW_post_work(transaction, dfw_modify_procedure, &desc,
			PRC.RDB$PROCEDURE_ID, PRC.RDB$PACKAGE_NAME);
		DFW_post_work_arg(transaction, dw2, NULL, 0, dfw_arg_check_blr);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields3, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		TRG IN RDB$TRIGGERS
			WITH DEP.RDB$DEPENDED_ON_NAME EQ field_source->dsc_address AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_trigger AND
				 DEP.RDB$DEPENDENT_NAME EQ TRG.RDB$TRIGGER_NAME
	{
		MetaName trigger_name(TRG.RDB$TRIGGER_NAME);
		MetaName relation_name(TRG.RDB$RELATION_NAME);

		dsc desc;
		desc.makeText(trigger_name.length(), CS_METADATA, (UCHAR*) trigger_name.c_str());

		DeferredWork* dw2 =
			DFW_post_work(transaction, dfw_modify_trigger, &desc, TRG.RDB$TRIGGER_TYPE);

		desc.makeText(relation_name.length(), CS_METADATA, (UCHAR*) relation_name.c_str());
		DFW_post_work_arg(transaction, dw2, &desc, 0, dfw_arg_check_blr);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields7, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		FUN IN RDB$FUNCTIONS
			WITH DEP.RDB$DEPENDED_ON_NAME EQ field_source->dsc_address AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
				 DEP.RDB$DEPENDENT_TYPE EQ obj_udf AND
				 DEP.RDB$DEPENDENT_NAME EQ FUN.RDB$FUNCTION_NAME AND
				 FUN.RDB$PACKAGE_NAME MISSING
	{
		MetaName name(FUN.RDB$FUNCTION_NAME);

		dsc desc;
		desc.makeText(name.length(), CS_METADATA, (UCHAR*) name.c_str());

		DeferredWork* dw2 =
			DFW_post_work(transaction, dfw_modify_function, &desc, FUN.RDB$FUNCTION_ID);
		DFW_post_work_arg(transaction, dw2, NULL, 0, dfw_arg_check_blr);
	}
	END_FOR

	request.reset(tdbb, irq_m_fields9, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DEP IN RDB$DEPENDENCIES CROSS
		FUN IN RDB$FUNCTIONS
			WITH DEP.RDB$DEPENDED_ON_NAME EQ field_source->dsc_address AND
				 DEP.RDB$DEPENDED_ON_TYPE EQ obj_field AND
				 (DEP.RDB$DEPENDENT_TYPE EQ obj_package_header OR
				 	DEP.RDB$DEPENDENT_TYPE EQ obj_package_body) AND
				 DEP.RDB$DEPENDENT_NAME EQ FUN.RDB$PACKAGE_NAME
	{
		MetaName name(FUN.RDB$FUNCTION_NAME);

		dsc desc;
		desc.makeText(name.length(), CS_METADATA, (UCHAR*) name.c_str());

		DeferredWork* dw2 = DFW_post_work(transaction, dfw_modify_function, &desc,
			FUN.RDB$FUNCTION_ID, FUN.RDB$PACKAGE_NAME);
		DFW_post_work_arg(transaction, dw2, NULL, 0, dfw_arg_check_blr);
	}
	END_FOR

	return dw;
}


void MET_delete_dependencies(thread_db* tdbb,
							 const MetaName& object_name,
							 int dependency_type,
							 jrd_tra* transaction)
{
/**************************************
 *
 *      M E T _ d e l e t e _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Delete all dependencies for the specified
 *      object of given type.
 *
 **************************************/
	SET_TDBB(tdbb);

	if (object_name.isEmpty())
		return;

	AutoCacheRequest request(tdbb, irq_d_deps, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		DEP IN RDB$DEPENDENCIES
			WITH DEP.RDB$DEPENDENT_NAME = object_name.c_str()
			AND DEP.RDB$DEPENDENT_TYPE = dependency_type
	{
		ERASE DEP;
	}
	END_FOR
}


void MET_delete_shadow(thread_db* tdbb, USHORT shadow_number)
{
/**************************************
 *
 *      M E T _ d e l e t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      When any of the shadows in RDB$FILES for a particular
 *      shadow are deleted, stop shadowing to that file and
 *      remove all other files from the same shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle)
		X IN RDB$FILES WITH X.RDB$SHADOW_NUMBER EQ shadow_number
		ERASE X;
	END_FOR

	for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
	{
		if (shadow->sdw_number == shadow_number) {
			shadow->sdw_flags |= SDW_shutdown;
		}
	}

	// notify other processes to check for shadow deletion
	if (SDW_lck_update(tdbb, 0))
		SDW_notify(tdbb);
}


bool MetadataCache::dsql_cache_use(thread_db* tdbb, sym_type type, const MetaName& name, const MetaName& package)
{
	const QualifiedName qualifiedName(name, package);
	DSqlCacheItem* item = get_dsql_cache_item(tdbb, type, qualifiedName);

	bool obsolete = false;
	item->obsoleteMap.get(qualifiedName, obsolete);

	if (!item->locked)
	{
		// lock to be notified by others when we should mark as obsolete
		LCK_lock(tdbb, item->lock, LCK_SR, LCK_WAIT);
		item->locked = true;
	}

	item->obsoleteMap.put(qualifiedName, false);

	return obsolete;
}


void MetadataCache::dsql_cache_release(thread_db* tdbb, sym_type type, const MetaName& name, const MetaName& package)
{
	const QualifiedName qualifiedName(name, package);
	DSqlCacheItem* item = get_dsql_cache_item(tdbb, type, qualifiedName);

	// release the shared lock
	LCK_release(tdbb, item->lock);

	// notify others through AST to mark as obsolete
	AutoPtr<Lock> tempExLock(FB_NEW_RPT(*tdbb->getDefaultPool(), item->key.length())
		Lock(tdbb, item->key.length(), LCK_dsql_cache));
	memcpy(tempExLock->getKeyPtr(), item->key.c_str(), item->key.length());

	if (LCK_lock(tdbb, tempExLock, LCK_EX, LCK_WAIT))
		LCK_release(tdbb, tempExLock);

	item->locked = false;

	GenericMap<Pair<Left<QualifiedName, bool> > >::Accessor accessor(&item->obsoleteMap);
	for (bool found = accessor.getFirst(); found; found = accessor.getNext())
		accessor.current()->second = accessor.current()->first != qualifiedName;
}


void MET_error(const TEXT* string, ...)
{
/**************************************
 *
 *      M E T _ e r r o r
 *
 **************************************
 *
 * Functional description
 *      Post an error in a metadata update
 *      Oh, wow.
 *
 **************************************/
	TEXT s[128];
	va_list ptr;

	va_start(ptr, string);
	VSNPRINTF(s, sizeof(s), string, ptr);
	va_end(ptr);

	ERR_post(Arg::Gds(isc_no_meta_update) <<
			 Arg::Gds(isc_random) << Arg::Str(s));
}

Format* MET_format(thread_db* tdbb, RelationPermanent* relation, USHORT number)
{
/**************************************
 *
 *      M E T _ f o r m a t
 *
 **************************************
 *
 * Functional description
 *      Lookup a format for given relation.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	Format* format;
	vec<Format*>* formats = relation->rel_formats;
	if (formats && (number < formats->count()) && (format = (*formats)[number]))
	{
		return format;
	}

	// System relations don't have their formats stored inside RDB$FORMATS,
	// so it's absolutely pointless trying to find one there
	fb_assert(!relation->isSystem());

	format = NULL;
	AutoCacheRequest request(tdbb, irq_r_format, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FORMATS WITH X.RDB$RELATION_ID EQ relation->getId() AND
			X.RDB$FORMAT EQ number
	{
		blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &X.RDB$DESCRIPTOR);

		// Use generic representation of formats with 32-bit offsets

		HalfStaticArray<UCHAR, BUFFER_MEDIUM> buffer;
		blob->BLB_get_data(tdbb, buffer.getBuffer(blob->blb_length), blob->blb_length);
		unsigned bufferPos = 2;
		USHORT count = buffer[0] | (buffer[1] << 8);

		format = Format::newFormat(relation->getPool(), count);

		Array<Ods::Descriptor> odsDescs;
		Ods::Descriptor* odsDesc = odsDescs.getBuffer(count);
		memcpy(odsDesc, buffer.begin() + bufferPos, count * sizeof(Ods::Descriptor));

		for (Format::fmt_desc_iterator desc = format->fmt_desc.begin();
			 desc < format->fmt_desc.end(); ++desc, ++odsDesc)
		{
			*desc = *odsDesc;
			if (odsDesc->dsc_offset)
				format->fmt_length = odsDesc->dsc_offset + desc->dsc_length;
		}

		const UCHAR* p = buffer.begin() + bufferPos + count * sizeof(Ods::Descriptor);
		count = p[0] | (p[1] << 8);
		p += 2;

		Array<UCHAR> tmpArray;	// must be aligned for the maximum datatype align requirement
		while (count-- > 0)
		{
			USHORT offset = p[0] | (p[1] << 8);
			p += 2;

			Ods::Descriptor odsDflDesc;
			memcpy(&odsDflDesc, p, sizeof(odsDflDesc));
			p += sizeof(Ods::Descriptor);

			dsc desc = odsDflDesc;

			desc.dsc_address = tmpArray.getBuffer(desc.dsc_length, false);
			memcpy(desc.dsc_address, p, desc.dsc_length);
			EVL_make_value(tdbb, &desc, &format->fmt_defaults[offset], &relation->getPool());

			p += desc.dsc_length;
		}
	}
	END_FOR

	if (!format)
		format = Format::newFormat(relation->getPool());

	format->fmt_version = number;

	// Link the format block into the world

	formats = relation->rel_formats =
		vec<Format*>::newVector(relation->getPool(), relation->rel_formats, number + 1);
	(*formats)[number] = format;

	return format;
}


bool MetadataCache::get_texttype(thread_db* tdbb, TTypeId* id, const UCHAR* name, USHORT length)
{
/**************************************
 *
 *      M E T _ g e t _ c h a r _ c o l l _ s u b t y p e
 *
 **************************************
 *
 * Functional description
 *      Character types can be specified as either:
 *         a) A POSIX style locale name "<collation>.<characterset>"
 *         or
 *         b) A simple <characterset> name (using default collation)
 *         c) A simple <collation> name    (use charset for collation)
 *
 *      Given an ASCII7 string which could be any of the above, try to
 *      resolve the name in the order a, b, c
 *      a) is only tried iff the name contains a period.
 *      (in which case b) and c) are not tried).
 *
 * Return:
 *      1 if no errors (and *id is set).
 *      0 if the name could not be resolved.
 *
 **************************************/
	SET_TDBB(tdbb);

	fb_assert(id != NULL);
	fb_assert(name != NULL);

	const UCHAR* const end_name = name + length;

	// Force key to uppercase, following C locale rules for uppercasing
	// At the same time, search for the first period in the string (if any)
	UCHAR buffer[MAX_SQL_IDENTIFIER_SIZE];			// BASED ON RDB$COLLATION_NAME
	UCHAR* p = buffer;
	UCHAR* period = NULL;
	for (; name < end_name && p < buffer + sizeof(buffer) - 1; p++, name++)
	{
		*p = UPPER7(*name);
		if ((*p == '.') && !period) {
			period = p;
		}
	}
	*p = 0;

	auto mdc = MetadataCache::get(tdbb);

	// Is there a period, separating collation name from character set?
	if (period)
	{
		*period = 0;
		return mdc->resolve_charset_and_collation(tdbb, id, period + 1, buffer);
	}

	// Is it a character set name (implying charset default collation sequence)

	bool res = mdc->resolve_charset_and_collation(tdbb, id, buffer, NULL);
	if (!res)
	{
		// Is it a collation name (implying implementation-default character set)
		res = mdc->resolve_charset_and_collation(tdbb, id, NULL, buffer);
	}
	return res;
}


bool MET_get_char_coll_subtype_info(thread_db* tdbb, USHORT id, SubtypeInfo* info)
{
/**************************************
 *
 *      M E T _ g e t _ c h a r _ c o l l _ s u b t y p e _ i n f o
 *
 **************************************
 *
	TODO - lookup in MDC first !!!!!!!!!!!!!!!!!

 * Functional description
 *      Get charset and collation informations
 *      for a subtype ID.
 *
 **************************************/
	fb_assert(info != NULL);

	const USHORT charset_id = id & 0x00FF;
	const USHORT collation_id = id >> 8;

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_l_subtype, IRQ_REQUESTS);
	bool found = false;
	info->charsetName.clear();

	FOR(REQUEST_HANDLE request) FIRST 1
		CL IN RDB$COLLATIONS CROSS
		CS IN RDB$CHARACTER_SETS
		WITH CL.RDB$CHARACTER_SET_ID EQ charset_id AND
			CL.RDB$COLLATION_ID EQ collation_id AND
			CS.RDB$CHARACTER_SET_ID EQ CL.RDB$CHARACTER_SET_ID
	{
		found = true;

		info->charsetName.push(CS.RDB$CHARACTER_SET_NAME);
		info->collationName = CL.RDB$COLLATION_NAME;

		if (CL.RDB$BASE_COLLATION_NAME.NULL)
			info->baseCollationName = info->collationName;
		else
			info->baseCollationName = CL.RDB$BASE_COLLATION_NAME;

		if (CL.RDB$SPECIFIC_ATTRIBUTES.NULL)
			info->specificAttributes.clear();
		else
		{
			blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &CL.RDB$SPECIFIC_ATTRIBUTES);
			const ULONG length = blob->blb_length;

			// ASF: Here info->specificAttributes is in UNICODE_FSS charset.
			// It will be converted to the collation charset in intl.cpp
			blob->BLB_get_data(tdbb, info->specificAttributes.getBuffer(length), length);
		}

		info->attributes = (USHORT)CL.RDB$COLLATION_ATTRIBUTES;
		info->ignoreAttributes = CL.RDB$COLLATION_ATTRIBUTES.NULL;
	}
	END_FOR

	return found;
}


DmlNode* MET_get_dependencies(thread_db* tdbb,
							  Cached::Relation* relation,
							  const UCHAR* blob,
							  const ULONG blob_length,
							  CompilerScratch* view_csb,
							  bid* blob_id,
							  Statement** statementPtr,
							  CompilerScratch** csb_ptr,
							  const MetaName& object_name,
							  int type,
							  USHORT flags,
							  jrd_tra* transaction,
							  const MetaName& domain_validation)
{
/**************************************
 *
 *      M E T _ g e t _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Get dependencies for an object by parsing
 *      the blr used in its definition.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(domain_validation.isEmpty() || object_name == domain_validation); // for now

	MemoryPool& pool = *tdbb->getDefaultPool();
	AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(pool) CompilerScratch(pool));
	CompilerScratch* csb = auto_csb;

	csb->csb_g_flags |= (csb_get_dependencies | flags);
	csb->csb_domain_validation = domain_validation;

	DmlNode* node;

	if (blob)
	{
		node = PAR_blr(tdbb, relation, blob, blob_length, view_csb, &csb, statementPtr,
			(type == obj_trigger && relation != NULL), 0);
	}
	else
	{
		node = MET_parse_blob(tdbb, relation, blob_id, &csb, statementPtr,
			(type == obj_trigger && relation != NULL), type == obj_validation);
	}

	if (type == obj_computed)
	{
		MetaName domainName;

		AutoRequest handle;

		FOR(REQUEST_HANDLE handle)
			RLF IN RDB$RELATION_FIELDS CROSS
				FLD IN RDB$FIELDS WITH
				RLF.RDB$FIELD_SOURCE EQ FLD.RDB$FIELD_NAME AND
				RLF.RDB$RELATION_NAME EQ relation->c_name() AND
				RLF.RDB$FIELD_NAME EQ object_name.c_str()
		{
			domainName = FLD.RDB$FIELD_NAME;
		}
		END_FOR

		if (type != obj_package_body)
			MET_delete_dependencies(tdbb, domainName, type, transaction);

		MET_store_dependencies(tdbb, csb->csb_dependencies, relation, domainName, type, transaction);
	}
	else
	{
		if (type != obj_package_body)
			MET_delete_dependencies(tdbb, object_name, type, transaction);

		MET_store_dependencies(tdbb, csb->csb_dependencies, relation, object_name, type, transaction);
	}

	if (csb_ptr)
		*csb_ptr = auto_csb.release();

	return node;
}


jrd_fld* MET_get_field(const jrd_rel* relation, USHORT id)
{
/**************************************
 *
 *      M E T _ g e t _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Get the field block for a field if possible.  If not,
 *      return NULL;
 *
 **************************************/
	vec<jrd_fld*>* vector;

	if (!relation || !(vector = relation->rel_fields) || id >= vector->count())
		return NULL;

	return (*vector)[id];
}


bool MET_get_repl_state(Jrd::thread_db* tdbb, const MetaName& name)
{
/**************************************
 *
 *      M E T _ g e t _ r e p l _ s t a t e
 *
 **************************************
 *
 * Functional description
 *      Return relication state (enabled/disabled)
 *      for either database or given relation.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* const attachment = tdbb->getAttachment();

	AutoRequest handle;
	bool state = false;

	if (name.hasData())
	{
		FOR(REQUEST_HANDLE handle)
			PTAB IN RDB$PUBLICATION_TABLES
			WITH PTAB.RDB$TABLE_NAME EQ name.c_str()
		{
			state = true;
			break;
		}
		END_FOR
	}
	else
	{
		FOR(REQUEST_HANDLE handle)
			PUB IN RDB$PUBLICATIONS
			WITH PUB.RDB$ACTIVE_FLAG EQ 1
		{
			state = true;
			break;
		}
		END_FOR
	}

	return state;
}


void MET_get_shadow_files(thread_db* tdbb, bool delete_files)
{
/**************************************
 *
 *      M E T _ g e t _ s h a d o w _ f i l e s
 *
 **************************************
 *
 * Functional description
 *      Check the shadows found in the database against
 *      our in-memory list: if any new shadow files have
 *      been defined since the last time we looked, start
 *      shadowing to them; if any have been deleted, stop
 *      shadowing to them.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle) X IN RDB$FILES
		WITH X.RDB$SHADOW_NUMBER NOT MISSING
			AND X.RDB$SHADOW_NUMBER NE 0
	{
		if ((X.RDB$FILE_FLAGS & FILE_shadow) && !(X.RDB$FILE_FLAGS & FILE_inactive))
		{
			const USHORT file_flags = X.RDB$FILE_FLAGS;
			SDW_start(tdbb, X.RDB$FILE_NAME, X.RDB$SHADOW_NUMBER, file_flags, delete_files);

			// if the shadow exists, mark the appropriate shadow
			// block as found for the purposes of this routine;
			// if the shadow was conditional and is no longer, note it

			for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
			{
				if ((shadow->sdw_number == X.RDB$SHADOW_NUMBER) && !(shadow->sdw_flags & SDW_IGNORE))
				{
					shadow->sdw_flags |= SDW_found;
					if (!(file_flags & FILE_conditional)) {
						shadow->sdw_flags &= ~SDW_conditional;
					}
					break;
				}
			}
		}
	}
	END_FOR

	// if any current shadows were not defined in database, mark
	// them to be shutdown since they don't exist anymore

	for (Shadow* shadow = dbb->dbb_shadow; shadow; shadow = shadow->sdw_next)
	{
		if (!(shadow->sdw_flags & SDW_found))
			shadow->sdw_flags |= SDW_shutdown;
		else
			shadow->sdw_flags &= ~SDW_found;
	}

	SDW_check(tdbb);
}


ScanResult DbTriggers::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
/********************************************
 *
 *      D b T r i g g e r s :: s c a n
 *
 ********************************************
 *
 * Functional description
 *      Load database-wide triggers from RDB$TRIGGERS.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	CHECK_DBB(dbb);

	if (flags & CacheFlag::NOCOMMIT)
		return ScanResult::REPEAT;

	auto type = perm->getId();
	FB_UINT64 mask = (type == DB_TRIGGER_DDL) ? TRIGGER_TYPE_MASK : ~FB_UINT64(0);
	type = (type == DB_TRIGGER_DDL) ? TRIGGER_TYPE_DDL : type | TRIGGER_TYPE_DB;

	AutoRequest trigger_request;
	jrd_tra* trans = tdbb->getTransaction() ? tdbb->getTransaction() : attachment->getSysTransaction();

	FOR(REQUEST_HANDLE trigger_request TRANSACTION_HANDLE trans)
		TRG IN RDB$TRIGGERS
		WITH TRG.RDB$RELATION_NAME MISSING AND
			 TRG.RDB$TRIGGER_INACTIVE EQ 0
		SORTED BY TRG.RDB$TRIGGER_SEQUENCE
	{
		if ((TRG.RDB$TRIGGER_TYPE & mask) == type)
		{
			MET_load_trigger(tdbb, nullptr, TRG.RDB$TRIGGER_NAME, [this](int)->Triggers& {return *this;});
		}
	}
	END_FOR

	return ScanResult::COMPLETE;
}


void MetadataCache::loadDbTriggers(thread_db* tdbb, unsigned int type)
{
/**************************************
 *
 *      l o a d _ d b _ t r i g g e r s
 *
 **************************************
 *
 * Functional description
 *      Load database triggers from RDB$TRIGGERS.
 *
 **************************************/

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	CHECK_DBB(dbb);

	fb_assert(type < DB_TRIGGERS_COUNT);
	auto* cacheElement = mdc_triggers[type].load(atomics::memory_order_acquire);

	if (!cacheElement)
	{
		// actual type will be taken into an account in DbTriggers::scan
		auto* newCacheElement = FB_NEW_POOL(getPool())
			Cached::Triggers(tdbb, getPool(), type, DbTriggers::makeLock, NoData());
		if (mdc_triggers[type].compare_exchange_strong(cacheElement, newCacheElement,
			atomics::memory_order_release, atomics::memory_order_acquire))
		{
			cacheElement = newCacheElement;
		}
		else
		{
			delete newCacheElement;
			return;
		}
	}

	DbTriggers* triggers = DbTriggers::create(tdbb, getPool(), cacheElement);
	try
	{
		if (cacheElement->storeObject(tdbb, triggers, 0) == StoreResult::DUP)
			DbTriggers::destroy(tdbb, triggers);
	}
	catch(const Exception&)
	{
		DbTriggers::destroy(tdbb, triggers);
		throw;
	}
}


void MET_load_trigger(thread_db* tdbb,
					  jrd_rel* relation,
					  const MetaName& trigger_name,
					  std::function<Triggers&(int)> triggers)
{
/**************************************
 *
 *      M E T _ l o a d _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Load triggers from RDB$TRIGGERS.  If a requested,
 *      also load triggers from RDB$RELATIONS.
 *
 **************************************/
	TEXT errmsg[MAX_ERRMSG_LEN + 1];

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	CHECK_DBB(dbb);

	if (relation)
	{
		// No need to load table triggers for ReadOnly databases,
		// since INSERT/DELETE/UPDATE statements are not going to be allowed
		// hvlad: GTT with ON COMMIT DELETE ROWS clause is writable

		if (dbb->readOnly() && !(getPermanent(relation)->rel_flags & REL_temp_tran))
			return;
	}

	// Scan RDB$TRIGGERS next

	AutoCacheRequest request(tdbb, irq_s_triggers, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		TRG IN RDB$TRIGGERS
		WITH TRG.RDB$TRIGGER_NAME EQ trigger_name.c_str() AND
			 (TRG.RDB$TRIGGER_INACTIVE MISSING OR TRG.RDB$TRIGGER_INACTIVE EQ 0)
	{
		// check if the trigger is to be fired without any permissions
		// checks. Verify such a claim
		USHORT trig_flags = (USHORT) TRG.RDB$FLAGS;

		// if there is an ignore permission flag, see if it is legit
		if ((TRG.RDB$FLAGS & TRG_ignore_perm) && !verify_TRG_ignore_perm(tdbb, trigger_name))
		{
			fb_msg_format(NULL, FB_IMPL_MSG_FACILITY_JRD_BUGCHK, 304, sizeof(errmsg),
							errmsg, MsgFormat::SafeArg() << trigger_name.c_str());
			ERR_log(FB_IMPL_MSG_FACILITY_JRD_BUGCHK, 304, errmsg);

			trig_flags &= ~TRG_ignore_perm;
		}

		bid debug_blob_id;
		debug_blob_id.clear();

		bid extBodyId;
		extBodyId.clear();

		if (!TRG.RDB$DEBUG_INFO.NULL)	// ODS_11_1
			debug_blob_id = TRG.RDB$DEBUG_INFO;

		MetaName engine;
		string entryPoint;

		if (!TRG.RDB$ENGINE_NAME.NULL)	// ODS_12_0
		{
			engine = TRG.RDB$ENGINE_NAME;
			extBodyId = TRG.RDB$TRIGGER_SOURCE;
		}

		if (!TRG.RDB$ENTRYPOINT.NULL)	// ODS_12_0
			entryPoint = TRG.RDB$ENTRYPOINT;

		TriState ssDefiner;

		// If SQL SECURITY for relation was not specified it will re-use DB default so we should not care about it
		if (!TRG.RDB$SQL_SECURITY.NULL)
			ssDefiner = (bool) TRG.RDB$SQL_SECURITY;
		else if (relation)
			ssDefiner = relation->rel_ss_definer;

		if (TRG.RDB$RELATION_NAME.NULL)
		{
			fb_assert(!relation);

			if ((TRG.RDB$TRIGGER_TYPE & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DB ||
				(TRG.RDB$TRIGGER_TYPE & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DDL)
			{
				// this is a database or DDL trigger
				get_trigger(tdbb,
							relation,
							&TRG.RDB$TRIGGER_BLR,
							&debug_blob_id,
							triggers(0),
							TRG.RDB$TRIGGER_NAME,
							TRG.RDB$TRIGGER_TYPE,
							trig_flags,
							engine,
							entryPoint,
							&extBodyId,
							ssDefiner);
			}
		}
		else
		{
			// dimitr: support for the universal triggers
			int trigger_action, slot_index = 0;
			while ((trigger_action = TRIGGER_ACTION_SLOT(TRG.RDB$TRIGGER_TYPE, ++slot_index)) > 0)
			{
				get_trigger(tdbb,
							relation,
							&TRG.RDB$TRIGGER_BLR,
							&debug_blob_id,
							triggers(trigger_action),
							TRG.RDB$TRIGGER_NAME,
							(UCHAR) trigger_action,
							trig_flags,
							engine,
							entryPoint,
							&extBodyId,
							ssDefiner);
			}
		}
	}
	END_FOR
}



void MET_lookup_cnstrt_for_index(thread_db* tdbb,
								 MetaName& constraint_name,
								 const MetaName& index_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ c n s t r t _ f o r _ i n d e x
 *
 **************************************
 *
 * Functional description
 *      Lookup  constraint name from index name, if one exists.
 *      Calling routine must pass a buffer of at least 32 bytes.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	constraint_name = "";
	AutoCacheRequest request(tdbb, irq_l_cnstrt, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_CONSTRAINTS WITH X.RDB$INDEX_NAME EQ index_name.c_str()
	{
		constraint_name = X.RDB$CONSTRAINT_NAME;
	}
	END_FOR
}


void MET_lookup_cnstrt_for_trigger(thread_db* tdbb,
								   MetaName& constraint_name,
								   MetaName& relation_name,
								   const MetaName& trigger_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ c n s t r t _ f o r _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Lookup  constraint name from trigger name, if one exists.
 *      Calling routine must pass a buffer of at least 32 bytes.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	constraint_name = "";
	relation_name = "";
	AutoCacheRequest request(tdbb, irq_l_check, IRQ_REQUESTS);
	AutoCacheRequest request2(tdbb, irq_l_check2, IRQ_REQUESTS);

	// utilize two requests rather than one so that we
	// guarantee we always return the name of the relation
	// that the trigger is defined on, even if we don't
	// have a check constraint defined for that trigger

	FOR(REQUEST_HANDLE request)
		Y IN RDB$TRIGGERS WITH
			Y.RDB$TRIGGER_NAME EQ trigger_name.c_str()
	{
		FOR(REQUEST_HANDLE request2)
			X IN RDB$CHECK_CONSTRAINTS WITH
				X.RDB$TRIGGER_NAME EQ Y.RDB$TRIGGER_NAME
		{
			constraint_name = X.RDB$CONSTRAINT_NAME;
		}
		END_FOR

		relation_name = Y.RDB$RELATION_NAME;
	}
	END_FOR
}


void MET_lookup_exception(thread_db* tdbb,
						  SLONG number,
						  MetaName& name,
						  string* message)
{
/**************************************
 *
 *      M E T _ l o o k u p _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup exception by number and return its name and message.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// We need to look up exception in RDB$EXCEPTIONS

	AutoCacheRequest request(tdbb, irq_l_exception, IRQ_REQUESTS);

	name = "";
	if (message)
		*message = "";

	FOR(REQUEST_HANDLE request)
		X IN RDB$EXCEPTIONS WITH X.RDB$EXCEPTION_NUMBER = number
	{
		if (!X.RDB$EXCEPTION_NAME.NULL)
			name = X.RDB$EXCEPTION_NAME;

		if (!X.RDB$MESSAGE.NULL && message)
			*message = X.RDB$MESSAGE;
	}
	END_FOR
}


bool MET_load_exception(thread_db* tdbb, ExceptionItem& item)
{
/**************************************
 *
 *      M E T _ l o a d _ e x c e p t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup exception by name and fill the passed instance.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// We need to look up exception in RDB$EXCEPTIONS

	AutoCacheRequest request(tdbb, irq_l_except_no, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$EXCEPTIONS WITH X.RDB$EXCEPTION_NAME = item.name.c_str()
	{
		item.type = ExceptionItem::XCP_CODE;
		item.code = X.RDB$EXCEPTION_NUMBER;
		item.secName = X.RDB$SECURITY_CLASS;

		return true;
	}
	END_FOR

	return false;
}


int MET_lookup_field(thread_db* tdbb, jrd_rel* relation, const MetaName& name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ f i e l d
 *
 **************************************
 *
 * Functional description
 *      Look up a field name.
 *
 *	if the field is not found return -1
 *
 *****************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// Start by checking field names that we already know
	vec<jrd_fld*>* vector = relation->rel_fields;

	if (vector)
	{
		int id = 0;
		vec<jrd_fld*>::iterator fieldIter = vector->begin();

		for (const vec<jrd_fld*>::const_iterator end = vector->end();  fieldIter < end;
			++fieldIter, ++id)
		{
			if (*fieldIter)
			{
				jrd_fld* field = *fieldIter;
				if (field->fld_name == name)
				{
					return id;
				}
			}
		}
	}

	// Not found.  Next, try system relations directly

	int id = -1;

	AutoCacheRequest request(tdbb, irq_l_field, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATION_FIELDS WITH
			X.RDB$RELATION_NAME EQ relation->c_name() AND
			X.RDB$FIELD_ID NOT MISSING AND
			X.RDB$FIELD_NAME EQ name.c_str()
	{
		id = X.RDB$FIELD_ID;
	}
	END_FOR

	return id;
}


BlobFilter* MET_lookup_filter(thread_db* tdbb, SSHORT from, SSHORT to)
{
/**************************************
 *
 *      M E T _ l o o k u p _ f i l t e r
 *
 **************************************
 *
 * Functional description
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();

	FPTR_BFILTER_CALLBACK filter = NULL;
	BlobFilter* blf = NULL;

	AutoCacheRequest request(tdbb, irq_r_filters, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$FILTERS WITH X.RDB$INPUT_SUB_TYPE EQ from AND
		X.RDB$OUTPUT_SUB_TYPE EQ to
	{
		filter = (FPTR_BFILTER_CALLBACK)
			Module::lookup(X.RDB$MODULE_NAME, X.RDB$ENTRYPOINT, dbb);
		if (filter)
		{
			blf = FB_NEW_POOL(*dbb->dbb_permanent) BlobFilter(*dbb->dbb_permanent);
			blf->blf_next = NULL;
			blf->blf_from = from;
			blf->blf_to = to;
			blf->blf_filter = filter;
			blf->blf_exception_message.printf(EXCEPTION_MESSAGE,
					X.RDB$FUNCTION_NAME, X.RDB$ENTRYPOINT, X.RDB$MODULE_NAME);
		}
	}
	END_FOR

	return blf;
}


bool MET_load_generator(thread_db* tdbb, GeneratorItem& item, bool* sysGen, SLONG* step)
{
/**************************************
 *
 *      M E T _ l o a d _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *      Lookup generator ID by its name and load its metadata into the passed object.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (item.name == MASTER_GENERATOR)
	{
		item.id = 0;
		if (sysGen)
			*sysGen = true;
		if (step)
			*step = 1;
		return true;
	}

	AutoCacheRequest request(tdbb, irq_r_gen_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_NAME EQ item.name.c_str()
	{
		item.id = X.RDB$GENERATOR_ID;
		item.secName = X.RDB$SECURITY_CLASS;
		if (sysGen)
			*sysGen = (X.RDB$SYSTEM_FLAG == fb_sysflag_system);
		if (step)
			*step = X.RDB$GENERATOR_INCREMENT;

		return true;
	}
	END_FOR

	return false;
}

SLONG MET_lookup_generator(thread_db* tdbb, const MetaName& name, bool* sysGen, SLONG* step)
{
/**************************************
 *
 *      M E T _ l o o k u p _ g e n e r a t o r
 *
 **************************************
 *
 * Functional description
 *      Lookup generator ID by its name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (name == MASTER_GENERATOR)
	{
		if (sysGen)
			*sysGen = true;
		if (step)
			*step = 1;
		return 0;
	}

	AutoCacheRequest request(tdbb, irq_l_gen_id, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_NAME EQ name.c_str()
	{
		if (sysGen)
			*sysGen = (X.RDB$SYSTEM_FLAG == fb_sysflag_system);
		if (step)
			*step = X.RDB$GENERATOR_INCREMENT;

		return X.RDB$GENERATOR_ID;
	}
	END_FOR

	return -1;
}

bool MET_lookup_generator_id(thread_db* tdbb, SLONG gen_id, MetaName& name, bool* sysGen)
{
/**************************************
 *
 *      M E T _ l o o k u p _ g e n e r a t o r _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup generator (aka gen_id) by ID. It will load
 *		the name in the third parameter.
 *
 **************************************/
	SET_TDBB (tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(gen_id != 0);

	name = "";

	AutoCacheRequest request(tdbb, irq_r_gen_id_num, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_ID EQ gen_id
	{
		if (sysGen)
			*sysGen = (X.RDB$SYSTEM_FLAG == fb_sysflag_system);

		name = X.RDB$GENERATOR_NAME;
	}
	END_FOR

	return name.hasData();
}

void MET_update_generator_increment(thread_db* tdbb, SLONG gen_id, SLONG step)
{
/**************************************
 *
 *      M E T _ u p d a t e _ g e n e r a t o r _ i n c r e m e n t
 *
 **************************************
 *
 * Functional description
 *      Update the step in a generator searched by ID.
 *		This function is for legacy code "SET GENERATOR TO value" only!
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_upd_gen_id_increm, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE request)
		X IN RDB$GENERATORS WITH X.RDB$GENERATOR_ID EQ gen_id

		// We never accept changing the step in sys gens.
		if (X.RDB$SYSTEM_FLAG == fb_sysflag_system)
			return;

		MODIFY X
			X.RDB$GENERATOR_INCREMENT = step;
		END_MODIFY
	END_FOR
}


IndexStatus MetadataCache::getIndexStatus(bool nullFlag, int state)
{
	if (nullFlag)
		return MET_index_active;

	switch (state)
	{
	case MET_index_active:
	case MET_index_inactive:
	case MET_index_deferred_active:
	case MET_index_deferred_drop:
		return (IndexStatus)state;

	default:
		break;
	}

	return MET_index_state_unknown;
}


ElementBase::ReturnedId MetadataCache::lookup_index_name(thread_db* tdbb, const MetaName& index_name,
	IndexStatus* status)
{
/**************************************
 *
 *      M E T _ l o o k u p _ i n d e x _ n a m e
 *
 **************************************
 *
 * Functional description
 *      Lookup index id from index name.
 *
 **************************************/
	SLONG id = -1;

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_l_index_name, IRQ_REQUESTS);

	*status = MET_index_state_unknown;

	FOR(REQUEST_HANDLE request)
		X IN RDB$INDICES WITH
			X.RDB$INDEX_NAME EQ index_name.c_str()
	{
		*status = getIndexStatus(X.RDB$INDEX_INACTIVE.NULL, X.RDB$INDEX_INACTIVE);

		if ((!X.RDB$INDEX_ID.NULL) && X.RDB$INDEX_ID)
			id = X.RDB$INDEX_ID - 1;
	}
	END_FOR

	return id;
}


void MET_lookup_index_code(thread_db* tdbb, Cached::Relation* relation, index_desc* idx)
{
/***********************************************
*
*	M E T _ l o o k u p _ i n d e x _ c o d e
*
************************************************
*
* Functional description
*	Lookup information about an index.
*
**************************************/
	SET_TDBB(tdbb);

	IndexVersion* idv = relation->lookup_index(tdbb, idx->idx_id, CacheFlag::AUTOCREATE);
	if (idv)
	{
		idx->idx_condition_node = idv->idv_condition;
		idx->idx_condition_statement = idv->idv_condition_statement;

		idx->idx_expression_node = idv->idv_expression;
		idx->idx_expression_statement = idv->idv_expression_statement;
		memcpy(&idx->idx_expression_desc, &idv->idv_expression_desc, sizeof(struct dsc));

		return;
	}
}


bool MET_lookup_index_expr_cond_blr(thread_db* tdbb, const MetaName& index_name, bid& expr_blob_id, bid& cond_blob_id)
{
/**************************************
 *
 *      M E T _ l o o k u p _ i n d e x _ e x p r _ c o n d _ b l r
 *
 **************************************
 *
 * Functional description
 *		Lookup index expression and\or condition blob ID to use it later by many
 *		attachments and avoid of run of same lookup queries by all of them.
 *		Used by parallel index creation code.
 *
 **************************************/

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	bool found = false;
	AutoCacheRequest request(tdbb, irq_l_exp_index_blr, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		IDX IN RDB$INDICES WITH
		IDX.RDB$INDEX_NAME EQ index_name.c_str()
	{
		found = !IDX.RDB$EXPRESSION_BLR.NULL || !IDX.RDB$CONDITION_BLR.NULL;
		expr_blob_id = IDX.RDB$EXPRESSION_BLR;
		cond_blob_id = IDX.RDB$CONDITION_BLR;
	}
	END_FOR;

	return found;
}


bool MET_lookup_partner(thread_db* tdbb, RelationPermanent* relation, index_desc* idx, const TEXT* index_name)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p a r t n e r
 *
 **************************************
 *
 * Functional description
 *      Find partner index participating in a
 *      foreign key relationship.
 *
 **************************************/

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (relation->rel_flags & REL_check_partners)
		relation->scanPartners(tdbb);

	if (idx->idx_flags & idx_foreign)
	{
		if (index_name)
		{
			// Since primary key index names aren't being cached, do a long
			// hard lookup. This is only called during index create for foreign keys.

			bool found = false;
			AutoRequest request;

			FOR(REQUEST_HANDLE request)
				IDX IN RDB$INDICES CROSS
					IND IN RDB$INDICES WITH
					IDX.RDB$RELATION_NAME EQ relation->c_name() AND
					(IDX.RDB$INDEX_ID EQ idx->idx_id + 1 OR
					 IDX.RDB$INDEX_NAME EQ index_name) AND
					IND.RDB$INDEX_NAME EQ IDX.RDB$FOREIGN_KEY AND
					IND.RDB$UNIQUE_FLAG = 1
			{
				//// ASF: Hack fix for CORE-4304, until nasty interactions between dfw and met are not resolved.
				const RelationPermanent* partner_relation = relation;
				if (relation->getName() != IND.RDB$RELATION_NAME)
					partner_relation = MetadataCache::lookupRelation(tdbb, IND.RDB$RELATION_NAME, CacheFlag::AUTOCREATE);

				if (partner_relation && !IDX.RDB$INDEX_INACTIVE && !IND.RDB$INDEX_INACTIVE)
				{
					idx->idx_primary_relation = partner_relation->getId();
					idx->idx_primary_index = IND.RDB$INDEX_ID - 1;
					fb_assert(idx->idx_primary_index != idx_invalid);
					found = true;
				}
			}
			END_FOR

			return found;
		}

		auto* references = relation->rel_foreign_refs;
		if (references)
		{
			for (auto& dep : *references)
			{
				if (idx->idx_id == dep.dep_reference_id)
				{
					idx->idx_primary_relation = dep.dep_relation;
					idx->idx_primary_index = dep.dep_index;
					return true;
				}
			}
		}
		return false;
	}
	else if (idx->idx_flags & (idx_primary | idx_unique))
	{
		auto* dependencies = relation->rel_primary_dpnds;
		if (dependencies)
		{
			for (auto& dep : *dependencies)
			{
				if (idx->idx_id == dep.dep_reference_id)
				{
					idx->idx_foreign_dep = dep;
					return true;
				}
			}
		}
		return false;
	}

	return false;
}


jrd_prc* MetadataCache::lookup_procedure(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Lookup procedure by name.  Name passed in is
 *      ASCIZ name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = MetadataCache::get(tdbb);


	// See if we already know the procedure by name

	auto* proc = mdc->mdc_procedures.lookup(tdbb,
		[name] (Cached::Procedure* proc) { return proc->getName() == name; }, flags);
	if (proc)
		return proc->getObject(tdbb, flags);

	if (!(flags & CacheFlag::AUTOCREATE))
		return nullptr;


	// We need to look up the procedure name in RDB$PROCEDURES

	jrd_prc* procedure = nullptr;

	AutoCacheRequest request(tdbb, irq_l_procedure, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		P IN RDB$PROCEDURES
		WITH P.RDB$PROCEDURE_NAME EQ name.identifier.c_str() AND
			 P.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		fb_assert(!procedure);
		procedure = mdc->mdc_procedures.getObject(tdbb, P.RDB$PROCEDURE_ID, flags);
	}
	END_FOR

	return procedure;
}


jrd_prc* MetadataCache::lookup_procedure_id(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ l o o k u p _ p r o c e d u r e _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup procedure by id.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = MetadataCache::get(tdbb);

	return mdc->mdc_procedures.getObject(tdbb, id, flags);
}


Function* MetadataCache::lookup_function(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
/************************************************
 *
 *      M E T _ l o o k u p _ f u n c t i o n
 *
 ************************************************
 *
 * Functional description
 *      Lookup function by name.  Name passed in is
 *      ASCIZ name.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = MetadataCache::get(tdbb);


	// See if we already know the function by name

	auto* func = mdc->mdc_functions.lookup(tdbb,
		[name] (Cached::Function* func) { return func->getName() == name; }, flags);
	if (func)
		return func->getObject(tdbb, flags);

	if (!(flags & CacheFlag::AUTOCREATE))
		return nullptr;


	// We need to look up the function in RDB$FUNCTIONS

	Function* function = nullptr;

	AutoCacheRequest request(tdbb, irq_l_fun_name, IRQ_REQUESTS);
	FOR(REQUEST_HANDLE request)
		X IN RDB$FUNCTIONS
		WITH X.RDB$FUNCTION_NAME EQ name.identifier.c_str() AND
			 X.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		fb_assert(!function);
		function = mdc->getFunction(tdbb, X.RDB$FUNCTION_ID, flags);
	}
	END_FOR

	return function;
}


Cached::Relation* MetadataCache::lookupRelation(thread_db* tdbb, const MetaName& name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = MetadataCache::get(tdbb);

	// See if we already know the relation by name
	auto* rc = mdc->mdc_relations.lookup(tdbb, [name](RelationPermanent* rel) { return rel->rel_name == name; }, flags);

	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	// We need to look up the relation name in RDB$RELATIONS
	AutoCacheRequest request(tdbb, irq_l_relation, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$RELATIONS WITH X.RDB$RELATION_NAME EQ name.c_str()
	{
		if (auto* relVers = mdc->mdc_relations.getObject(tdbb, X.RDB$RELATION_ID, flags))
			rc = relVers->rel_perm;
	}
	END_FOR

	return rc;
}

jrd_rel* MetadataCache::lookup_relation(thread_db* tdbb, const MetaName& name, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ l o o k u p _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Lookup relation by name.  Name passed in is
 *      ASCIZ name.
 *
 **************************************/
	SET_TDBB(tdbb);

	auto* perm = lookupRelation(tdbb, name, flags);
	if (!perm)
		return nullptr;

	return MetadataCache::get(tdbb)->mdc_relations.getObject(tdbb, perm->getId(), flags);
}


jrd_rel* MetadataCache::lookup_relation_id(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ l o o k u p _ r e l a t i o n _ i d
 *
 **************************************
 *
 * Functional description
 *      Lookup relation by id. Make sure it really exists.
 *
 **************************************/
	SET_TDBB(tdbb);

	return MetadataCache::get(tdbb)->mdc_relations.getObject(tdbb, id, flags);
}


CharSetVers* MetadataCache::lookup_charset(thread_db* tdbb, CSetId id, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	return MetadataCache::get(tdbb)->mdc_charsets.getObject(tdbb, id, flags);
}


DmlNode* MET_parse_blob(thread_db*					tdbb,
				   Cached::Relation*				relation,
				   bid*								blob_id,
				   CompilerScratch**				csb_ptr,
				   Statement**						statementPtr,
				   const bool						trigger,
				   bool 							validationExpr)
{
/**************************************
 *
 *      M E T _ p a r s e _ b l o b
 *
 **************************************
 *
 * Functional description
 *      Parse blr, returning a compiler scratch block with the results.
 *
 * if ignore_perm is true then, the request generated must be set to
 *   ignore all permissions checks. In this case, we call PAR_blr
 *   passing it the csb_ignore_perm flag to generate a request
 *   which must go through without checking any permissions.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	blb* blob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);
	ULONG length = blob->blb_length + 10;
	HalfStaticArray<UCHAR, 512> tmp;
	UCHAR* temp = tmp.getBuffer(length);
	length = blob->BLB_get_data(tdbb, temp, length);

	DmlNode* node = NULL;

	if (validationExpr)
	{
		// The set of MET parse functions needs a rework.
		// For now, our caller chain is not interested in the returned node.
		PAR_validation_blr(tdbb, relation, temp, length, NULL, csb_ptr, 0);
	}
	else
		node = PAR_blr(tdbb, relation, temp, length, NULL, csb_ptr, statementPtr, trigger, 0);

	return node;
}


void MET_prepare(thread_db* tdbb, jrd_tra* transaction, USHORT length, const UCHAR* msg)
{
/**************************************
 *
 *      M E T _ p r e p a r e
 *
 **************************************
 *
 * Functional description
 *      Post a transaction description to RDB$TRANSACTIONS.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_s_trans, IRQ_REQUESTS);

	STORE(REQUEST_HANDLE request) X IN RDB$TRANSACTIONS
	{
		X.RDB$TRANSACTION_ID = transaction->tra_number;
		X.RDB$TRANSACTION_STATE = RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.LIMBO;
		blb* blob = blb::create(tdbb, attachment->getSysTransaction(), &X.RDB$TRANSACTION_DESCRIPTION);
		blob->BLB_put_segment(tdbb, msg, length);
		blob->BLB_close(tdbb);
	}
	END_STORE
}


jrd_prc* MetadataCache::findProcedure(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Find or create a procedure block for a given procedure id.
 *
 **************************************/
	SET_TDBB(tdbb);

	return MetadataCache::get(tdbb)->mdc_procedures.getObject(tdbb, id, flags);
}

jrd_prc* jrd_prc::create(thread_db* tdbb, MemoryPool&, Cached::Procedure* perm)
{
	return FB_NEW_POOL(perm->getPool()) jrd_prc(perm);
}

ScanResult jrd_prc::scan(thread_db* tdbb, ObjectBase::Flag)
{
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	MetadataCache* mdc = dbb->dbb_mdc;
	bool found = false;

	{
		AutoCacheRequest request(tdbb, irq_r_procedure, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request)
			P IN RDB$PROCEDURES WITH P.RDB$PROCEDURE_ID EQ getId()
		{
			found = true;

			if (getName().toString().length() == 0)
			{
				getPermanent()->name = QualifiedName(P.RDB$PROCEDURE_NAME,
					(P.RDB$PACKAGE_NAME.NULL ? "" : P.RDB$PACKAGE_NAME));
			}

			MetaName secClass;
			TriState ssDefiner;

			if (!P.RDB$SECURITY_CLASS.NULL)
				secClass = P.RDB$SECURITY_CLASS;
			else if (!P.RDB$PACKAGE_NAME.NULL)
			{
				AutoCacheRequest requestHandle(tdbb, irq_l_procedure_pkg_class, IRQ_REQUESTS);

				FOR (REQUEST_HANDLE requestHandle)
					PKG IN RDB$PACKAGES
					WITH PKG.RDB$PACKAGE_NAME EQ P.RDB$PACKAGE_NAME
				{
					if (!PKG.RDB$SECURITY_CLASS.NULL)
						secClass = PKG.RDB$SECURITY_CLASS;

					if (!PKG.RDB$SQL_SECURITY.NULL)
						ssDefiner = (bool) PKG.RDB$SQL_SECURITY;
				}
				END_FOR
			}

			if (getPermanent()->securityName.length() == 0)
				getPermanent()->securityName = secClass;

			if (ssDefiner.isUnknown())
			{
				if (!P.RDB$SQL_SECURITY.NULL)
					ssDefiner = (bool) P.RDB$SQL_SECURITY;
				else
					ssDefiner = MET_get_ss_definer(tdbb);
			}

			if (getPermanent()->owner.length() == 0)
				getPermanent()->owner = P.RDB$OWNER_NAME;

			if (ssDefiner.asBool())
				invoker = attachment->getUserId(getPermanent()->owner);

			setImplemented(true);
			setDefined(true);
			getInputFields().resize(P.RDB$PROCEDURE_INPUTS);
			getOutputFields().resize(P.RDB$PROCEDURE_OUTPUTS);
			setDefaultCount(0);

			AutoCacheRequest request2(tdbb, irq_r_params, IRQ_REQUESTS);

			const MetaName packageName(P.RDB$PACKAGE_NAME.NULL ? NULL : P.RDB$PACKAGE_NAME);

			FOR (REQUEST_HANDLE request2)
				PA IN RDB$PROCEDURE_PARAMETERS
				CROSS F IN RDB$FIELDS
				WITH F.RDB$FIELD_NAME = PA.RDB$FIELD_SOURCE AND
					 PA.RDB$PROCEDURE_NAME = P.RDB$PROCEDURE_NAME AND
					 PA.RDB$PACKAGE_NAME EQUIV NULLIF(packageName.c_str(), '')
			{
				const SSHORT pa_collation_id_null = PA.RDB$COLLATION_ID.NULL;
				const CollId pa_collation_id(PA.RDB$COLLATION_ID);
				const SSHORT pa_default_value_null = PA.RDB$DEFAULT_VALUE.NULL;
				bid pa_default_value = pa_default_value_null ? F.RDB$DEFAULT_VALUE : PA.RDB$DEFAULT_VALUE;

				Array<NestConst<Parameter> >& paramArray = PA.RDB$PARAMETER_TYPE ?
					getOutputFields() : getInputFields();

				// should be error if field already exists
				Parameter* parameter = FB_NEW_POOL(mdc->getPool()) Parameter(mdc->getPool());
				parameter->prm_number = PA.RDB$PARAMETER_NUMBER;
				paramArray[parameter->prm_number] = parameter;
				parameter->prm_name = PA.RDB$PARAMETER_NAME;
				parameter->prm_nullable = PA.RDB$NULL_FLAG.NULL || PA.RDB$NULL_FLAG == 0;	// ODS_11_1
				parameter->prm_mechanism = PA.RDB$PARAMETER_MECHANISM.NULL ?	// ODS_11_1
					prm_mech_normal : (prm_mech_t) PA.RDB$PARAMETER_MECHANISM;

				if (!PA.RDB$FIELD_SOURCE.NULL)
					parameter->prm_field_source = PA.RDB$FIELD_SOURCE;

				DSC_make_descriptor(&parameter->prm_desc, F.RDB$FIELD_TYPE,
									F.RDB$FIELD_SCALE, F.RDB$FIELD_LENGTH,
									F.RDB$FIELD_SUB_TYPE, CSetId(F.RDB$CHARACTER_SET_ID),
									(pa_collation_id_null ? CollId(F.RDB$COLLATION_ID) : pa_collation_id));

				if (F.RDB$FIELD_TYPE == blr_blob)
					parameter->prm_seg_length = F.RDB$SEGMENT_LENGTH;

				if (parameter->prm_desc.isText() && parameter->prm_desc.getTextType() != CS_NONE)
				{
					if (!pa_collation_id_null || fb_utils::implicit_domain(PA.RDB$FIELD_SOURCE))
						parameter->prm_text_type = parameter->prm_desc.getTextType();
				}

				if (!PA.RDB$RELATION_NAME.NULL)
					parameter->prm_type_of_table = PA.RDB$RELATION_NAME;

				if (!PA.RDB$FIELD_NAME.NULL)
					parameter->prm_type_of_column = PA.RDB$FIELD_NAME;

				if (PA.RDB$PARAMETER_TYPE == 0 &&
					(!pa_default_value_null ||
					 (fb_utils::implicit_domain(F.RDB$FIELD_NAME) && !F.RDB$DEFAULT_VALUE.NULL)))
				{
					setDefaultCount(getDefaultCount() + 1);
					MemoryPool* pool = dbb->createPool(ALLOC_ARGS0);
					Jrd::ContextPoolHolder context(tdbb, pool);

					try
					{
						parameter->prm_default_value = static_cast<ValueExprNode*>(
							MET_parse_blob(tdbb, nullptr, &pa_default_value, NULL, NULL, false, false));
					}
					catch (const Exception&)
					{
						// Here we lose pools created for previous defaults.
						// Probably we should use common pool for defaults and procedure itself.

						dbb->deletePool(pool);
						throw;
					}
				}
			}
			END_FOR

			const bool external = !P.RDB$ENGINE_NAME.NULL;	// ODS_12_0

			Array<NestConst<Parameter> >& paramArray = getOutputFields();

			if (paramArray.hasData() && paramArray[0])
			{
				Format* format = Format::newFormat(mdc->getPool(), getOutputFields().getCount());
				prc_record_format = format;
				ULONG length = FLAG_BYTES(format->fmt_count);
				Format::fmt_desc_iterator desc = format->fmt_desc.begin();
				Array<NestConst<Parameter> >::iterator ptr, end;
				for (ptr = paramArray.begin(), end = paramArray.end(); ptr < end; ++ptr, ++desc)
				{
					const Parameter* parameter = *ptr;
					// check for parameter to be null, this can only happen if the
					// parameter numbers get out of sync. This was added to fix bug
					// 10534. -Shaunak Mistry 12-May-99
					if (parameter)
					{
						*desc = parameter->prm_desc;
						length = MET_align(&(*desc), length);
						desc->dsc_address = (UCHAR *) (IPTR) length;
						length += desc->dsc_length;
					}
				}

				format->fmt_length = length;
			}

			prc_type = P.RDB$PROCEDURE_TYPE.NULL ?
				prc_legacy : (prc_t) P.RDB$PROCEDURE_TYPE;

			if (external || !P.RDB$PROCEDURE_BLR.NULL)
			{
				MemoryPool* const csb_pool = dbb->createPool(ALLOC_ARGS0);
				Jrd::ContextPoolHolder context(tdbb, csb_pool);

				try
				{
					AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

					if (external)
					{
						HalfStaticArray<char, 512> body;

						if (!P.RDB$PROCEDURE_SOURCE.NULL)
						{
							blb* blob = blb::open(tdbb, attachment->getSysTransaction(),
								&P.RDB$PROCEDURE_SOURCE);
							ULONG len = blob->BLB_get_data(tdbb,
								(UCHAR*) body.getBuffer(blob->blb_length + 1), blob->blb_length + 1);
							body.begin()[MIN(blob->blb_length, len)] = '\0';
						}
						else
							body.getBuffer(1)[0] = '\0';

						dbb->dbb_extManager->makeProcedure(tdbb, csb, this, P.RDB$ENGINE_NAME,
							(P.RDB$ENTRYPOINT.NULL ? "" : P.RDB$ENTRYPOINT), body.begin());

						if (!getExternal())
							setDefined(false);
					}
					else
					{
						const string name = getName().toString();

						try
						{
							TraceProcCompile trace(tdbb, name);

							parseBlr(tdbb, csb, &P.RDB$PROCEDURE_BLR,
								P.RDB$DEBUG_INFO.NULL ? NULL : &P.RDB$DEBUG_INFO);

							trace.finish(getStatement(), ITracePlugin::RESULT_SUCCESS);
						}
						catch (const Exception& ex)
						{
							StaticStatusVector temp_status;
							ex.stuffException(temp_status);
							(Arg::Gds(isc_bad_proc_BLR) << Arg::Str(name)
								<< Arg::StatusVector(temp_status.begin())).raise();
						}
					}
				}
				catch (const Exception&)
				{
					if (getStatement())
						releaseStatement(tdbb);
					else
						dbb->deletePool(csb_pool);

					throw;
				}

				fb_assert(!isDefined() || getStatement()->procedure == this);
			}
			else
			{
				RefPtr<MsgMetadata> inputMetadata(REF_NO_INCR,
					Routine::createMetadata(getInputFields(), false));
				setInputFormat(
					Routine::createFormat(getPermanent()->getPool(), inputMetadata, false));

				RefPtr<MsgMetadata> outputMetadata(REF_NO_INCR,
					Routine::createMetadata(getOutputFields(), false));
				setOutputFormat(
					Routine::createFormat(getPermanent()->getPool(), outputMetadata, true));

				setImplemented(false);
			}

			if (!dbb->readOnly() &&
				!P.RDB$PROCEDURE_BLR.NULL &&
				!P.RDB$VALID_BLR.NULL && P.RDB$VALID_BLR == FALSE)
			{
				// If the BLR was marked as invalid but the procedure was compiled,
				// mark the BLR as valid.

				MODIFY P USING
					P.RDB$VALID_BLR = TRUE;
					P.RDB$VALID_BLR.NULL = FALSE;
				END_MODIFY
			}
		}
		END_FOR
	}

	return found ? (this->flReload ? ScanResult::REPEAT : ScanResult::COMPLETE) : ScanResult::MISS;
}

void jrd_prc::checkReload(thread_db* tdbb) const
{
	if (flReload)
		getPermanent()->reload(tdbb, 0);
}

ScanResult jrd_prc::reload(thread_db* tdbb, ObjectBase::Flag /*unused*/)
{
	fb_assert(flReload);

	Attachment* attachment = tdbb->getAttachment();
	AutoCacheRequest request(tdbb, irq_r_proc_blr, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		P IN RDB$PROCEDURES WITH P.RDB$PROCEDURE_ID EQ this->getId()
	{
		MemoryPool* const csb_pool = tdbb->getDatabase()->createPool(ALLOC_ARGS0);
		Jrd::ContextPoolHolder context(tdbb, csb_pool);

		try
		{
			AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

			try
			{
				this->parseBlr(tdbb, csb, &P.RDB$PROCEDURE_BLR,
					P.RDB$DEBUG_INFO.NULL ? NULL : &P.RDB$DEBUG_INFO);

				return flReload ? ScanResult::REPEAT : ScanResult::COMPLETE;
			}
			catch (const Exception& ex)
			{
				StaticStatusVector temp_status;
				ex.stuffException(temp_status);

				const string name = this->getName().toString();
				(Arg::Gds(isc_bad_proc_BLR) << Arg::Str(name)
					<< Arg::StatusVector(temp_status.begin())).raise();
			}
		}
		catch (const Exception&)
		{
			tdbb->getDatabase()->deletePool(csb_pool);
			throw;
		}
	}
	END_FOR

	return ScanResult::MISS;
}


void MET_revoke(thread_db* tdbb, jrd_tra* transaction, const MetaName& relation,
	const MetaName& revokee, const string& privilege)
{
/**************************************
 *
 *      M E T _ r e v o k e
 *
 **************************************
 *
 * Functional description
 *      Execute a recursive revoke.  This is called only when
 *      a revoked privilege had the grant option.
 *
 **************************************/
	SET_TDBB(tdbb);

	// See if the revokee still has the privilege.  If so, there's nothing to do

	USHORT count = 0;

	AutoCacheRequest request(tdbb, irq_revoke1, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		FIRST 1 P IN RDB$USER_PRIVILEGES WITH
			P.RDB$RELATION_NAME EQ relation.c_str() AND
			P.RDB$PRIVILEGE EQ privilege.c_str() AND
			P.RDB$USER EQ revokee.c_str()
	{
		++count;
	}
	END_FOR

	if (count)
		return;

	request.reset(tdbb, irq_revoke2, IRQ_REQUESTS);

	// User lost privilege.  Take it away from anybody he/she gave it to.

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		P IN RDB$USER_PRIVILEGES WITH
			P.RDB$RELATION_NAME EQ relation.c_str() AND
			P.RDB$PRIVILEGE EQ privilege.c_str() AND
			P.RDB$GRANTOR EQ revokee.c_str()
	{
		ERASE P;
	}
	END_FOR
}


void MET_scan_partners(thread_db* tdbb, RelationPermanent* relation)
{
/**************************************
 *
 *      M E T _ s c a n _ p a r t n e r s
 *
 **************************************
 *
 * Functional description
 *      Scan of foreign references on other relations' primary keys and
 *      scan of primary dependencies on relation's primary key.
 *
 **************************************/

	SET_TDBB(tdbb);

	if (relation->rel_flags & REL_check_partners)
		relation->scanPartners(tdbb);
}


ScanResult jrd_rel::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
/**************************************
 *
 *      M E T _ s c a n _ r e l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Scan a relation for view RecordSelExpr, computed by expressions, missing
 *      expressions, and validation expressions.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	Jrd::ContextPoolHolder context(tdbb, dbb->dbb_permanent);
	blb* blob = NULL;
	bool found = false;

	jrd_tra* trans = tdbb->getTransaction() ?
		tdbb->getTransaction() : attachment->getSysTransaction();

	if (flags & CacheFlag::NOCOMMIT)
	{
		// New version of relation is created currently.
		// Perform only very basic scan - may be more changes to come.
		// scan() will be called automatically w/o NOCOMMIT
		// on any attempt to use modified relation
		// or on transaction commit.

		if (getName().isEmpty())
		{
			static const CachedRequestId requestCacheId;
			AutoCacheRequest request(tdbb, requestCacheId);

			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE trans)
				REL IN RDB$RELATIONS WITH REL.RDB$RELATION_ID EQ getId()
			{
				rel_perm->rel_name = REL.RDB$RELATION_NAME;
				rel_perm->rel_flags |= get_rel_flags_from_FLAGS(REL.RDB$FLAGS);
				if (!REL.RDB$RELATION_TYPE.NULL)
					rel_perm->rel_flags |= MET_get_rel_flags_from_TYPE(REL.RDB$RELATION_TYPE);
			}
			END_FOR
		}

		fb_assert(getName().hasData());		// i.e. correct record in RDB$RELATIONS exists
		if (getName().hasData())
		{
			rel_perm->rel_flags |= REL_format;

			// Next time reload() will be called
			return ScanResult::REPEAT;
		}

		// something gone wrong
		return ScanResult::MISS;
	}

	bool dependencies = (rel_perm->rel_flags & REL_get_dependencies) ? true : false;

	// If anything errors, cleanup to reset the flag.
	// This will ensure that the error will be caught if the operation is tried again.
	Cleanup onError([&] {
		if (dependencies)
			rel_perm->rel_flags |= REL_get_dependencies;

		if (blob)
			blob->BLB_close(tdbb);
	});

	rel_perm->rel_flags &= ~REL_get_dependencies;

	// Do we need new format version?
	if (rel_perm->rel_flags & REL_format)
	{
		RelationNode::makeVersion(tdbb, trans, rel_perm->getName());
		rel_perm->rel_flags &= ~REL_format;
	}

	// Since this can be called recursively, find an inactive clone of the request

	AutoCacheRequest request(tdbb, irq_r_fields, IRQ_REQUESTS);
	CompilerScratch* csb = NULL;

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE trans)
		REL IN RDB$RELATIONS WITH REL.RDB$RELATION_ID EQ getId()
	{
		found = true;

		if (getName().isEmpty())
		{
			rel_perm->rel_name = REL.RDB$RELATION_NAME;
			rel_perm->rel_flags |= REL_check_partners;
		}

		rel_perm->rel_flags |= get_rel_flags_from_FLAGS(REL.RDB$FLAGS);
		if (!REL.RDB$RELATION_TYPE.NULL)
			rel_perm->rel_flags |= MET_get_rel_flags_from_TYPE(REL.RDB$RELATION_TYPE);

		// Pick up relation level stuff
		rel_dbkey_length = REL.RDB$DBKEY_LENGTH;
		fb_assert(rel_dbkey_length % 8 == 0);
		if (!rel_dbkey_length)
			rel_dbkey_length = 8;

		rel_current_fmt = REL.RDB$FORMAT;
		rel_fields = vec<jrd_fld*>::newVector(*rel_pool, rel_fields, REL.RDB$FIELD_ID);
		if (rel_perm->rel_security_name.isEmpty() && !REL.RDB$SECURITY_CLASS.NULL)
			rel_perm->rel_security_name = REL.RDB$SECURITY_CLASS;

		rel_perm->rel_owner_name = REL.RDB$OWNER_NAME;

		if (!REL.RDB$SQL_SECURITY.NULL)
			rel_ss_definer = (bool) REL.RDB$SQL_SECURITY;
		else
			rel_ss_definer = MET_get_ss_definer(tdbb);

		if (!REL.RDB$VIEW_BLR.isEmpty())
		{
			// parse the view blr, getting dependencies on relations, etc. at the same time

			DmlNode* rseNode;

			if (dependencies)
			{
				const MetaName depName(REL.RDB$RELATION_NAME);
				rseNode = MET_get_dependencies(tdbb, getPermanent(), NULL, 0, NULL, &REL.RDB$VIEW_BLR,
					NULL, &csb, depName, obj_view, 0, trans);
			}
			else
				rseNode = MET_parse_blob(tdbb, rel_perm, &REL.RDB$VIEW_BLR, &csb, NULL, false, false);

			if (rseNode)
			{
				fb_assert(rseNode->getKind() == DmlNode::KIND_REC_SOURCE);
				rel_view_rse = nodeAs<RseNode>(static_cast<RecordSourceNode*>(rseNode));
				fb_assert(rel_view_rse);
			}
			else
				rel_view_rse = NULL;

			// retrieve the view context names

			lookup_view_contexts(tdbb, this);
		}

		if (REL.RDB$EXTERNAL_FILE[0] && !rel_perm->getExtFile())
		{
			rel_perm->setExtFile(ExternalFile::create(getPool(), REL.RDB$EXTERNAL_FILE));
		}

		if (!REL.RDB$RELATION_TYPE.NULL)
		{
			switch (REL.RDB$RELATION_TYPE)
			{
				case rel_persistent:
					break;
				case rel_external:
					fb_assert(getExtFile());
					break;
				case rel_view:
					fb_assert(rel_view_rse);
					fb_assert(rel_perm->rel_flags & REL_jrd_view);
					rel_perm->rel_flags |= REL_jrd_view;
					break;
				case rel_virtual:
					fb_assert(rel_perm->rel_flags & REL_virtual);
					rel_perm->rel_flags |= REL_virtual;
					break;
				case rel_global_temp_preserve:
					fb_assert(rel_perm->rel_flags & REL_temp_conn);
					rel_perm->rel_flags |= REL_temp_conn;
					break;
				case rel_global_temp_delete:
					fb_assert(rel_perm->rel_flags & REL_temp_tran);
					rel_perm->rel_flags |= REL_temp_tran;
					break;
				default:
					fb_assert(false);
			}
		}

		// Pick up field specific stuff

		blob = blb::open(tdbb, attachment->getSysTransaction(), &REL.RDB$RUNTIME);
		HalfStaticArray<UCHAR, 256> temp;
		UCHAR* const buffer = temp.getBuffer(blob->getMaxSegment() + 1U);

		jrd_fld* field = NULL;
		ArrayField* array = 0;
		USHORT view_context = 0;
		USHORT field_id = 0;
		for (;;)
		{
			USHORT length = blob->BLB_get_segment(tdbb, buffer, blob->getMaxSegment());
			if (blob->blb_flags & BLB_eof)
			{
				break;
			}
			USHORT n;
			buffer[length] = 0;
			UCHAR* p = (UCHAR*) &n;
			const UCHAR* q = buffer + 1;
			while (q < buffer + 1 + sizeof(SSHORT))
			{
				*p++ = *q++;
			}
			p = buffer + 1;
			--length;
			switch ((rsr_t) buffer[0])
			{
			case RSR_field_id:
				if (field && field->fld_security_name.length() == 0 && !REL.RDB$DEFAULT_CLASS.NULL)
				{
					field->fld_security_name = REL.RDB$DEFAULT_CLASS;
				}
				field_id = n;
				field = (*rel_fields)[field_id];

				if (field)
				{
					field->fld_computation = NULL;
					field->fld_missing_value = NULL;
					field->fld_default_value = NULL;
					field->fld_validation = NULL;
					field->fld_not_null = NULL;
					field->fld_generator_name = NULL;
				}

				array = NULL;
				break;

			case RSR_field_name:
				if (field)
				{
					// The field exists.  If its name hasn't changed, then
					// there's no need to copy anything.

					if (field->fld_name == reinterpret_cast<char*>(p))
						break;
				}
				else
				{
					field = FB_NEW_POOL(*rel_pool) jrd_fld(*rel_pool);
					(*rel_fields)[field_id] = field;
				}
				field->fld_name = reinterpret_cast<char*>(p);

				// CVC: Be paranoid and allow the possible trigger(s) to have a
				//   not null security class to work on, even if we only take it
				//   from the this itself.
				if (field->fld_security_name.length() == 0 && !REL.RDB$DEFAULT_CLASS.NULL)
				{
					field->fld_security_name = REL.RDB$DEFAULT_CLASS;
				}

				break;

			case RSR_field_source:
				field->fld_source_name = reinterpret_cast<char*>(p);
				break;

			case RSR_view_context:
				view_context = n;
				break;

			case RSR_base_field:
				if (dependencies)
				{
					csb->csb_g_flags |= csb_get_dependencies;
					field->fld_source = PAR_make_field(tdbb, csb, view_context, (TEXT*) p);
					const MetaName depName(REL.RDB$RELATION_NAME);
					MET_store_dependencies(tdbb, csb->csb_dependencies, nullptr, depName, obj_view, trans);
				}
				else
					field->fld_source = PAR_make_field(tdbb, csb, view_context, (TEXT*) p);

				{	// scope
					const ViewContexts& ctx = rel_view_contexts;
					FB_SIZE_T pos;

					if (ctx.find(view_context, pos) &&
						(ctx[pos]->vcx_type == VCT_TABLE || ctx[pos]->vcx_type == VCT_VIEW))
					{
						field->fld_source_rel_field = MetaNamePair(ctx[pos]->vcx_relation_name, (TEXT*) p);
					}
				}

				break;

			case RSR_computed_blr:
				{
					AutoSetRestoreFlag<USHORT> flag(&field->fld_flags, FLD_parse_computed, true);

					DmlNode* nod = dependencies ?
						MET_get_dependencies(tdbb, getPermanent(), p, length, csb, NULL, NULL, NULL,
							field->fld_name, obj_computed, csb_computed_field, trans) :
						PAR_blr(tdbb, rel_perm, p, length, csb, NULL, NULL, false, csb_computed_field);

					field->fld_computation = static_cast<ValueExprNode*>(nod);
				}
				break;

			case RSR_missing_value:
				field->fld_missing_value = static_cast<ValueExprNode*>(
					PAR_blr(tdbb, rel_perm, p, length, csb, NULL, NULL, false, 0));
				break;

			case RSR_default_value:
				field->fld_default_value = static_cast<ValueExprNode*>(
					PAR_blr(tdbb, rel_perm, p, length, csb, NULL, NULL, false, 0));
				break;

			case RSR_validation_blr:
				// AB: 2005-04-25   bug SF#1168898
				// Ignore validation for VIEWs, because fields (domains) which are
				// defined with CHECK constraints and have sub-selects should at least
				// be parsed without view-context information. With view-context
				// information the context-numbers are wrong.
				// Because a VIEW can't have a validation section i ignored the whole call.
				if (!csb)
				{
					field->fld_validation = PAR_validation_blr(tdbb, rel_perm, p, length, csb,
						NULL, csb_validation);
				}
				break;

			case RSR_field_not_null:
				field->fld_not_null = PAR_validation_blr(tdbb, rel_perm, p, length, csb,
					NULL, csb_validation);
				break;

			case RSR_security_class:
				field->fld_security_name = (const TEXT*) p;
				break;

			case RSR_trigger_name:
				MET_load_trigger(tdbb, this, (const TEXT*) p, [&](int t)->Triggers& {return rel_triggers[t];});
				break;

			case RSR_dimensions:
				field->fld_array = array = FB_NEW_RPT(*rel_pool, n) ArrayField();
				array->arr_desc.iad_dimensions = n;
				break;

			case RSR_array_desc:
				if (array)
					memcpy(&array->arr_desc, p, length);
				break;

			case RSR_field_generator_name:
				field->fld_generator_name = (const TEXT*) p;
				if (!field->fld_identity_type.has_value())
					field->fld_identity_type = IDENT_TYPE_BY_DEFAULT;
				break;

			case RSR_field_identity_type:
				field->fld_identity_type = static_cast<IdentityType>(n);
				break;

			case RSR_field_length:
				field->fld_length = n;
				break;

			case RSR_segment_length:
				field->fld_segment_length = n;
				break;

			case RSR_field_pos:
				field->fld_pos = n;
				break;

			case RSR_character_length:
				field->fld_character_length = n;
				break;

			default:    // Shut up compiler warning
				break;
			}
		}
		blob->BLB_close(tdbb);
		blob = nullptr;

		if (field && field->fld_security_name.length() == 0 && !REL.RDB$DEFAULT_CLASS.NULL)
		{
			field->fld_security_name = REL.RDB$DEFAULT_CLASS;
		}
	}
	END_FOR

	delete csb;

	rel_current_format = MET_format(tdbb, rel_perm, rel_current_fmt);
	dependencies = false;

	if (rel_fields)
		rel_fields->trimNulls();

	LCK_lock(tdbb, rel_perm->rel_rescan_lock, LCK_SR, LCK_WAIT);

	return found ? ScanResult::COMPLETE : ScanResult::MISS;
}


void MET_trigger_msg(thread_db* tdbb, string& msg, const MetaName& name,
	USHORT number)
{
/**************************************
 *
 *      M E T _ t r i g g e r _ m s g
 *
 **************************************
 *
 * Functional description
 *      Look up trigger message using trigger and abort code.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_s_msgs, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		MSG IN RDB$TRIGGER_MESSAGES WITH
			MSG.RDB$TRIGGER_NAME EQ name.c_str() AND
			MSG.RDB$MESSAGE_NUMBER EQ number
	{
		msg = MSG.RDB$MESSAGE;
	}
	END_FOR

	msg.rtrim();
}


void MET_update_shadow(thread_db* tdbb, Shadow* shadow, USHORT file_flags)
{
/**************************************
 *
 *      M E T _ u p d a t e _ s h a d o w
 *
 **************************************
 *
 * Functional description
 *      Update the stored file flags for the specified shadow.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle)
		FIL IN RDB$FILES WITH FIL.RDB$SHADOW_NUMBER EQ shadow->sdw_number
	{
		MODIFY FIL USING
			FIL.RDB$FILE_FLAGS = file_flags;
		END_MODIFY
	}
	END_FOR
}


void MET_update_transaction(thread_db* tdbb, jrd_tra* transaction, const bool do_commit)
{
/**************************************
 *
 *      M E T _ u p d a t e _ t r a n s a c t i o n
 *
 **************************************
 *
 * Functional description
 *      Update a record in RDB$TRANSACTIONS.  If do_commit is true, this is a
 *      commit; otherwise it is a ROLLBACK.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	AutoCacheRequest request(tdbb, irq_m_trans, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		X IN RDB$TRANSACTIONS
		WITH X.RDB$TRANSACTION_ID EQ transaction->tra_number
	{
		if (do_commit && (transaction->tra_flags & TRA_prepare2))
			ERASE X
		else
		{
			MODIFY X
				X.RDB$TRANSACTION_STATE = do_commit ?
					RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.COMMITTED :
					RDB$TRANSACTIONS.RDB$TRANSACTION_STATE.ROLLED_BACK;
			END_MODIFY
		}
	}
	END_FOR
}


static int blocking_ast_dsql_cache(void* ast_object)
{
/**************************************
 *
 *	b l o c k i n g _ a s t _ d s q l _ c a c h e
 *
 **************************************
 *
 * Functional description
 *	Someone is trying to drop an item from the DSQL cache.
 *	Mark the symbol as obsolete and release the lock.
 *
 **************************************/
	DSqlCacheItem* const item = static_cast<DSqlCacheItem*>(ast_object);

	try
	{
		Database* const dbb = item->lock->lck_dbb;

		AsyncContextHolder tdbb(dbb, FB_FUNCTION, item->lock);

		GenericMap<Pair<Left<QualifiedName, bool> > >::Accessor accessor(&item->obsoleteMap);
		for (bool found = accessor.getFirst(); found; found = accessor.getNext())
			accessor.current()->second = true;

		item->locked = false;
		LCK_release(tdbb, item->lock);
	}
	catch (const Exception&)
	{} // no-op

	return 0;
}


DSqlCacheItem* MetadataCache::get_dsql_cache_item(thread_db* tdbb, sym_type type, const QualifiedName& name)
{
	Database* dbb = tdbb->getDatabase();
	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = MetadataCache::get(tdbb);

	fb_assert((int) type <= MAX_UCHAR);
	UCHAR ucharType = (UCHAR) type;

	string key("0");	// name (not hash)
	key.append((char*) &ucharType, 1);

	USHORT len = (USHORT) name.identifier.length();
	key.append((char*) &len, sizeof(len));
	key.append(name.identifier.c_str(), len);

	len = (USHORT) name.package.length();
	key.append((char*) &len, sizeof(len));
	key.append(name.package.c_str(), len);

	if (key.length() > MAX_UCHAR)
	{
		FB_SIZE_T hash = DefaultHash<char>::hash(key.c_str(), key.length(), sizeof(FB_SIZE_T));
		key = "1";	// hash
		key.append((char*) &ucharType, 1);
		key.append((char*) &hash, sizeof(hash));
	}

	DSqlCacheItem* item = attachment->att_dsql_cache.put(key);
	if (item)
	{
		item->key = key;
		item->lock = FB_NEW_RPT(mdc->getPool(), key.length())
			Lock(tdbb, key.length(), LCK_dsql_cache, item, blocking_ast_dsql_cache);
		memcpy(item->lock->getKeyPtr(), key.c_str(), key.length());
	}
	else
		item = attachment->att_dsql_cache.get(key);

	return item;
}


int RelationPermanent::partners_ast_relation(void* ast_object)
{
	auto* const relation = static_cast<Cached::Relation*>(ast_object);

	try
	{
		Database* const dbb = relation->rel_partners_lock->lck_dbb;

		AsyncContextHolder tdbb(dbb, FB_FUNCTION, relation->rel_partners_lock);

		if (!(relation->rel_flags & REL_check_partners))
		{
			relation->rel_flags |= REL_check_partners;
			LCK_release(tdbb, relation->rel_partners_lock);
		}
	}
	catch (const Exception&)
	{} // no-op

	return 0;
}


int RelationPermanent::rescan_ast_relation(void* ast_object)
{
	auto* const relation = static_cast<Cached::Relation*>(ast_object);

	try
	{
		Database* const dbb = relation->rel_rescan_lock->lck_dbb;

		AsyncContextHolder tdbb(dbb, FB_FUNCTION, relation->rel_rescan_lock);

		relation->resetDependentObject(tdbb, ElementBase::ResetType::Mark);
		LCK_release(tdbb, relation->rel_rescan_lock);
	}
	catch (const Firebird::Exception&)
	{} // no-op

	return 0;
}


int RelationPermanent::blocking_ast_relation(void* ast_object)
{
	auto* const relation = static_cast<Cached::Relation*>(ast_object);

	try
	{
		Database* const dbb = relation->rel_existence_lock->lck_dbb;

		AsyncContextHolder tdbb(dbb, FB_FUNCTION, relation->rel_existence_lock);

// ???????????????????????????????		cacheElement->resetDependentObject(tdbb, ElementBase::ResetType::Drop);
		LCK_release(tdbb, relation->rel_existence_lock);
	}
	catch (const Firebird::Exception&)
	{} // no-op

	return 0;
}


static ULONG get_rel_flags_from_FLAGS(USHORT flags)
{
/**************************************
 *
 *      g e t _ r e l _ f l a g s _ f r o m _ F L A G S
 *
 **************************************
 *
 * Functional description
 *      Get rel_flags from RDB$FLAGS
 *
 **************************************/
	ULONG ret = 0;

	if (flags & REL_sql) {
		ret |= REL_sql_relation;
	}

	return ret;
}


ULONG MET_get_rel_flags_from_TYPE(USHORT type)
{
/**************************************
 *
 *      M E T _g e t _ r e l _ f l a g s _ f r o m _ T Y P E
 *
 **************************************
 *
 * Functional description
 *      Get rel_flags from RDB$RELATION_TYPE
 *
 **************************************/
	ULONG ret = 0;

	switch (type)
	{
		case rel_persistent:
			break;
		case rel_external:
			break;
		case rel_view:
			ret |= REL_jrd_view;
			break;
		case rel_virtual:
			ret |= REL_virtual;
			break;
		case rel_global_temp_preserve:
			ret |= REL_temp_conn;
			break;
		case rel_global_temp_delete:
			ret |= REL_temp_tran;
			break;
		default:
			fb_assert(false);
	}

	return ret;
}


static void get_trigger(thread_db* tdbb, jrd_rel* relation,
						bid* blob_id, bid* debug_blob_id, Triggers& triggers,
						const TEXT* name, FB_UINT64 type, USHORT flags,
						const MetaName& engine, const string& entryPoint,
						const bid* body, TriState ssDefiner)
{
/**************************************
 *
 *      g e t _ t r i g g e r
 *
 **************************************
 *
 * Functional description
 *      Get trigger.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	if (blob_id->isEmpty() && (engine.isEmpty() || entryPoint.isEmpty()))
		return;

	blb* blrBlob = NULL;
	blb* debugInfoBlob = NULL;

	if (!blob_id->isEmpty())
		blrBlob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);

	if (!debug_blob_id->isEmpty())
		debugInfoBlob = blb::open(tdbb, attachment->getSysTransaction(), debug_blob_id);

	save_trigger_data(tdbb, triggers, relation, NULL, blrBlob, debugInfoBlob,
					  name, type, flags, engine, entryPoint, body, ssDefiner);
}

/* !!!!!!!!!!!!!!!!!!!!
static bool get_type(thread_db* tdbb, USHORT* id, const UCHAR* name, const TEXT* field)
{
 **************************************
 *
 *      g e t _ t y p e
 *
 **************************************
 *
 * Functional description
 *      Resoved a symbolic name in RDB$TYPES.  Returned the value
 *      defined for the name in (*id).  Don't touch (*id) if you
 *      don't find the name.
 *
 *      Return (1) if found, (0) otherwise.
 *
 **************************************
	UCHAR buffer[MAX_SQL_IDENTIFIER_SIZE];			// BASED ON RDB$TYPE_NAME

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(id != NULL);
	fb_assert(name != NULL);
	fb_assert(field != NULL);

	// Force key to uppercase, following C locale rules for uppercase
	UCHAR* p;
	for (p = buffer; *name && p < buffer + sizeof(buffer) - 1; p++, name++)
	{
		*p = UPPER7(*name);
	}
	*p = 0;

	// Try for exact name match

	bool found = false;

	AutoRequest handle;

	FOR(REQUEST_HANDLE handle)
		FIRST 1 T IN RDB$TYPES WITH
			T.RDB$FIELD_NAME EQ field AND
			T.RDB$TYPE_NAME EQ buffer
	{
		found = true;
		*id = T.RDB$TYPE;
	}
	END_FOR

	return found;
}
*/

static void lookup_view_contexts( thread_db* tdbb, jrd_rel* view)
{
/**************************************
 *
 *      l o o k u p _ v i e w _ c o n t e x t s
 *
 **************************************
 *
 * Functional description
 *      Lookup view contexts and store in a sorted
 *      array on the relation block.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	AutoCacheRequest request(tdbb, irq_view_context, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		V IN RDB$VIEW_RELATIONS WITH
			V.RDB$VIEW_NAME EQ view->c_name()
			SORTED BY V.RDB$VIEW_CONTEXT
	{
		// trim trailing spaces
		fb_utils::exact_name_limit(V.RDB$CONTEXT_NAME, sizeof(V.RDB$CONTEXT_NAME));

		ViewContext* view_context = FB_NEW_POOL(*view->rel_pool)
			ViewContext(*view->rel_pool,
				V.RDB$CONTEXT_NAME, V.RDB$RELATION_NAME, V.RDB$VIEW_CONTEXT,
				(V.RDB$CONTEXT_TYPE.NULL ? VCT_TABLE : ViewContextType(V.RDB$CONTEXT_TYPE)));

		view->rel_view_contexts.add(view_context);
	}
	END_FOR
}


static void make_relation_scope_name(const TEXT* rel_name, const USHORT rel_flags,
	string& str)
{
/**************************************
 *
 *	m a k e _ r e l a t i o n _ s c o p e _ n a m e
 *
 **************************************
 *
 * Functional description
 *	Make string with relation name and type
 *	of its temporary scope
 *
 **************************************/
	const char *scope = NULL;
	if (rel_flags & REL_temp_conn)
		scope = REL_SCOPE_GTT_PRESERVE;
	else if (rel_flags & REL_temp_tran)
		scope = REL_SCOPE_GTT_DELETE;
	else
		scope = REL_SCOPE_PERSISTENT;

	str.printf(scope, rel_name);
}


// Parses default BLR for a field.
static ValueExprNode* parse_field_default_blr(thread_db* tdbb, bid* blob_id)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	MemoryPool& pool = *tdbb->getDefaultPool();
	AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(pool) CompilerScratch(pool));
	CompilerScratch* csb = auto_csb;

	blb* blob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);
	ULONG length = blob->blb_length + 10;
	HalfStaticArray<UCHAR, 512> temp;

	length = blob->BLB_get_data(tdbb, temp.getBuffer(length), length);

	DmlNode* const node = PAR_blr(tdbb, nullptr, temp.begin(), length, NULL, &csb, NULL, false, 0);
	return static_cast<ValueExprNode*>(node);
}


// Parses validation BLR for a field.
static BoolExprNode* parse_field_validation_blr(thread_db* tdbb, bid* blob_id, const MetaName name)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	MemoryPool& pool = *tdbb->getDefaultPool();
	AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(pool) CompilerScratch(pool));
	CompilerScratch* csb = auto_csb;

	csb->csb_domain_validation = name;

	blb* blob = blb::open(tdbb, attachment->getSysTransaction(), blob_id);
	ULONG length = blob->blb_length + 10;
	HalfStaticArray<UCHAR, 512> temp;

	length = blob->BLB_get_data(tdbb, temp.getBuffer(length), length);

	return PAR_validation_blr(tdbb, nullptr, temp.begin(), length, NULL, &csb, 0);
}


bool MetadataCache::resolve_charset_and_collation(thread_db* tdbb, TTypeId* id,
												  const UCHAR* charset, const UCHAR* collation)
{
/**************************************
 *
 *      r e s o l v e _ c h a r s e t _ a n d _ c o l l a t i o n
 *
 **************************************
 *
 * Functional description
 *      Given ASCII7 name of charset & collation
 *      resolve the specification to a Character set id.
 *      This character set id is also the id of the text_object
 *      that implements the C locale for the Character set.
 *
 * Inputs:
 *      (charset)
 *              ASCII7z name of character set.
 *              NULL (implying unspecified) means use the character set
 *              for defined for (collation).
 *
 *      (collation)
 *              ASCII7z name of collation.
 *              NULL means use the default collation for (charset).
 *
 * Outputs:
 *      (*id)
 *              Set to character set specified by this name (low byte)
 *              Set to collation specified by this name (high byte).
 *
 * Return:
 *      true if no errors (and *id is set).
 *      false if either name not found.
 *        or if names found, but the collation isn't for the specified
 *        character set.
 *
 **************************************/
	CharSetVers* csVer = nullptr;

	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	fb_assert(id != NULL);

	AutoRequest handle;

	if ((!collation) && (!charset))
		charset = (const UCHAR*) DEFAULT_CHARACTER_SET_NAME;

	if (charset)
	{
		MetaName name = (const char*) charset;
		auto* cs = mdc_charsets.lookup(tdbb,
			[name](CharSetContainer* csc)
			{
				return csc->names.exist(name);
			},
			0
		);

		if (!cs)
		{
			FOR(REQUEST_HANDLE handle)
				FIRST 1 CS IN RDB$CHARACTER_SETS
				CROSS T IN RDB$TYPES
				WITH T.RDB$TYPE_NAME EQ charset
				 AND T.RDB$FIELD_NAME EQ "RDB$CHARACTER_SET_NAME"
				 AND T.RDB$TYPE EQ CS.RDB$CHARACTER_SET_ID
			{
				csVer = mdc_charsets.getObject(tdbb, CS.RDB$CHARACTER_SET_ID, CacheFlag::AUTOCREATE);
				cs = csVer->getContainer();
			}
			END_FOR

			if (!cs)
				return false;
		}

		if (!collation)
		{
			*id = TTypeId(cs->getId());
			return true;
		}

		if (!csVer)
			csVer = cs->getObject(tdbb, CacheFlag::AUTOCREATE);
		Collation* coll = csVer->getCollation((const char*)collation);

		if (!coll)
			return false;
	}

	fb_assert(collation);

	bool found = false;
	if (!charset)
	{
		FOR(REQUEST_HANDLE handle)
			FIRST 1 COL IN RDB$COLLATIONS
				WITH COL.RDB$COLLATION_NAME EQ collation
		{
			found = true;
			*id = TTypeId(CSetId(COL.RDB$CHARACTER_SET_ID), CollId(COL.RDB$COLLATION_ID));
		}
		END_FOR
	}

	return found;
}


ScanResult CharSetVers::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	fb_assert(perm->hasData());

	Attachment* attachment = tdbb->getAttachment();

	AutoRequest handle, handle2;

	if (perm->names.getCount() == 0)
	{
		perm->names.push(getName());

		FOR(REQUEST_HANDLE handle)
			T IN RDB$TYPES
			WITH T.RDB$FIELD_NAME EQ "RDB$CHARACTER_SET_NAME"
			 AND T.RDB$TYPE EQ getId()
		{
			if (getName() != T.RDB$TYPE_NAME)
				perm->names.push(T.RDB$TYPE_NAME);
		}
		END_FOR
	}

	FOR(REQUEST_HANDLE handle2)
		CS IN RDB$CHARACTER_SETS
			CROSS COL IN RDB$COLLATIONS OVER RDB$CHARACTER_SET_ID
		WITH CS.RDB$CHARACTER_SET_ID EQ getId()
	{
		fb_assert(perm->names.exist(CS.RDB$CHARACTER_SET_NAME));

		SubtypeInfo info;
		info.charsetName = perm->names;
		info.collationName = COL.RDB$COLLATION_NAME;
		info.attributes = (USHORT)COL.RDB$COLLATION_ATTRIBUTES;
		info.ignoreAttributes = COL.RDB$COLLATION_ATTRIBUTES.NULL;

		if (COL.RDB$BASE_COLLATION_NAME.NULL)
			info.baseCollationName = info.collationName;
		else
			info.baseCollationName = COL.RDB$BASE_COLLATION_NAME;

		CharSet* charset = perm->getCharSet();
		CollId colId(COL.RDB$COLLATION_ID);
		CSetId id(getId());

		if (COL.RDB$SPECIFIC_ATTRIBUTES.NULL)
			info.specificAttributes.clear();
		else
		{
			blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &COL.RDB$SPECIFIC_ATTRIBUTES);
			const ULONG length = blob->blb_length;

			// ASF: Here info.specificAttributes is in UNICODE_FSS charset.
			blob->BLB_get_data(tdbb, info.specificAttributes.getBuffer(length), length);

			if (id != CS_METADATA)
			{
				Firebird::UCharBuffer specificAttributes;
				ULONG size = info.specificAttributes.getCount() * charset->maxBytesPerChar();

				size = INTL_convert_bytes(tdbb, id,
									  specificAttributes.getBuffer(size), size,
									  CS_METADATA, info.specificAttributes.begin(),
									  info.specificAttributes.getCount(), ERR_post);
				specificAttributes.shrink(size);
				info.specificAttributes = specificAttributes;
			}
		}

		AutoPtr<texttype> tt = FB_NEW_POOL(perm->getPool()) texttype;
		memset(tt, 0, sizeof(texttype));
		INTL_lookup_texttype(tt, &info);

		if (charset_collations.getCount() <= colId)
			charset_collations.grow(colId + 1);

		fb_assert((tt->texttype_canonical_width == 0 && tt->texttype_fn_canonical == NULL) ||
				  (tt->texttype_canonical_width != 0 && tt->texttype_fn_canonical != NULL));

		if (tt->texttype_canonical_width == 0)
		{
			if (charset->isMultiByte())
				tt->texttype_canonical_width = sizeof(ULONG);	// UTF-32
			else
			{
				tt->texttype_canonical_width = charset->minBytesPerChar();
				// canonical is equal to string, then TEXTTYPE_DIRECT_MATCH can be turned on
				tt->texttype_flags |= TEXTTYPE_DIRECT_MATCH;
			}
		}

		Collation* collation = Collation::createInstance(perm->getPool(),
			TTypeId(id, colId), tt, info.attributes, charset);
		collation->name = info.collationName;

		tt.release();
		charset_collations[colId] = collation;
	}
	END_FOR

//	return found ? ScanResult::COMPLETE : ScanResult::REPEAT;
	return ScanResult::COMPLETE;
}


static void save_trigger_data(thread_db* tdbb, Triggers& vector, jrd_rel* relation,
							  Statement* statement, blb* blrBlob, blb* debugInfoBlob,
							  const TEXT* name, FB_UINT64 type, USHORT flags,
							  const MetaName& engine, const string& entryPoint,
							  const bid* body, TriState ssDefiner)
{
/**************************************
 *
 *      s a v e _ t r i g g e r _ d a t a
 *
 **************************************
 *
 * Functional description
 *      Save trigger data to passed vector
 *
 **************************************/
	Attachment* attachment = tdbb->getAttachment();
	Database* database = tdbb->getDatabase();
	MemoryPool& pool(*(relation ? relation->rel_pool : database->dbb_permanent));

	Trigger* t = FB_NEW_POOL(pool) Trigger(pool);

	if (blrBlob)
	{
		const ULONG length = blrBlob->blb_length + 10;
		UCHAR* const data = t->blr.getBuffer(length);
		t->blr.resize(blrBlob->BLB_get_data(tdbb, data, length));
	}

	if (debugInfoBlob)
	{
		const ULONG length = debugInfoBlob->blb_length + 10;
		UCHAR* const data = t->debugInfo.getBuffer(length);
		t->debugInfo.resize(debugInfoBlob->BLB_get_data(tdbb, data, length));
	}

	if (name)
		t->name = name;

	if (body)
	{
		blb* bodyBlob = blb::open(tdbb, attachment->getSysTransaction(), body);

		HalfStaticArray<char, 512> temp;
		ULONG length = bodyBlob->BLB_get_data(tdbb, (UCHAR*) temp.getBuffer(bodyBlob->blb_length),
			bodyBlob->blb_length);

		t->extBody.assign(temp.begin(), length);
	}

	t->type = type;
	t->flags = flags;
	t->statement = statement;
	t->relation = relation;			// trigger can't exist longer than relation
	t->engine = engine;
	t->entryPoint = entryPoint;
	t->ssDefiner = ssDefiner;
	t->owner = relation ? relation->getOwnerName() : tdbb->getDatabase()->dbb_owner;

	vector.addTrigger(tdbb, t);
}


void RelationPermanent::scanPartners(thread_db* tdbb)
{
/**************************************
 *
 *      s c a n _ p a r t n e r s
 *
 **************************************
 *
 * Functional description
 *      Scan of foreign references on other relations' primary keys and
 *      scan of primary dependencies on relation's primary key.
 *
 **************************************/
	Attachment* attachment = tdbb->getAttachment();

	if (rel_flags & REL_check_partners)
	{
		LCK_lock(tdbb, rel_partners_lock, LCK_SR, LCK_WAIT);

		// Prepare for rescan of foreign dependencies on relation.

		AutoCacheRequest request(tdbb, irq_foreign1, IRQ_REQUESTS);
		int index_number = 0;

		if (rel_foreign_refs)
		{
			delete rel_foreign_refs;
			rel_foreign_refs = NULL;
		}

		FOR(REQUEST_HANDLE request)
			IDX IN RDB$INDICES CROSS
			RC IN RDB$RELATION_CONSTRAINTS
			OVER RDB$INDEX_NAME CROSS
			IND IN RDB$INDICES WITH
			RC.RDB$CONSTRAINT_TYPE EQ FOREIGN_KEY AND
			IDX.RDB$RELATION_NAME EQ c_name() AND
			IND.RDB$INDEX_NAME EQ IDX.RDB$FOREIGN_KEY AND
			IDX.RDB$INDEX_ID > 0 AND
			IND.RDB$INDEX_ID > 0 AND
			IND.RDB$UNIQUE_FLAG = 1
		{
			//// ASF: Hack fix for CORE-4304, until nasty interactions between dfw and met are not resolved.
			const RelationPermanent* partner_relation = this;
			if (getName() != IND.RDB$RELATION_NAME)
				partner_relation = MetadataCache::lookupRelation(tdbb, IND.RDB$RELATION_NAME, CacheFlag::AUTOCREATE);

			if (partner_relation && !IDX.RDB$INDEX_INACTIVE && !IND.RDB$INDEX_INACTIVE)
			{
				dep deps;
				deps.dep_reference_id = IDX.RDB$INDEX_ID - 1;
				deps.dep_relation = partner_relation->getId();
				deps.dep_index = IND.RDB$INDEX_ID - 1;

				if (!rel_foreign_refs)
					rel_foreign_refs = FB_NEW_POOL(getPool()) ForeignRefs(getPool());

				rel_foreign_refs->push(deps);
			}
		}
		END_FOR

		// Prepare for rescan of primary dependencies on relation's primary key and stale vectors.

		request.reset(tdbb, irq_foreign2, IRQ_REQUESTS);
		if (rel_primary_dpnds)
		{
			delete rel_primary_dpnds;
			rel_primary_dpnds = NULL;
		}

		FOR(REQUEST_HANDLE request)
			IDX IN RDB$INDICES CROSS
			IND IN RDB$INDICES WITH
			IDX.RDB$UNIQUE_FLAG = 1 AND
			IDX.RDB$INDEX_ID > 0 AND
			IND.RDB$INDEX_ID > 0 AND
			IDX.RDB$RELATION_NAME EQ c_name() AND
			IND.RDB$FOREIGN_KEY EQ IDX.RDB$INDEX_NAME
		{
			//// ASF: Hack fix for CORE-4304, until nasty interactions between dfw and met are not resolved.
			const auto* partner_relation = this;
			if (getName() != IND.RDB$RELATION_NAME)
				partner_relation = MetadataCache::lookupRelation(tdbb, IND.RDB$RELATION_NAME, CacheFlag::AUTOCREATE);

			if (partner_relation && !IDX.RDB$INDEX_INACTIVE && !IND.RDB$INDEX_INACTIVE)
			{
				dep deps;
				deps.dep_reference_id = IDX.RDB$INDEX_ID - 1;
				deps.dep_relation = partner_relation->getId();
				deps.dep_index = IND.RDB$INDEX_ID - 1;

				if (!rel_primary_dpnds)
					rel_primary_dpnds = FB_NEW_POOL(getPool()) PrimaryDeps(getPool());

				rel_primary_dpnds->push(deps);
			}
		}
		END_FOR

		rel_flags &= ~REL_check_partners;
	}
}


const Trigger* jrd_rel::findTrigger(const MetaName trig_name) const
{
	for (int n = TRIGGER_PRE_STORE; n <= TRIGGER_POST_ERASE; ++n)
	{
		for (auto t : rel_triggers[n])
		{
			if (t->name == trig_name)
				return t;
		}
	}

	return nullptr;
}


void MET_store_dependencies(thread_db* tdbb,
							Array<Dependency>& dependencies,
							Cached::Relation* dep_rel,
							const MetaName& object_name,
							int dependency_type,
							jrd_tra* transaction)
{
/**************************************
 *
 *      s t o r e _ d e p e n d e n c i e s
 *
 **************************************
 *
 * Functional description
 *      Store records in RDB$DEPENDENCIES
 *      corresponding to the objects found during
 *      compilation of blr for a trigger, view, etc.
 *
 **************************************/
	MetaName name;

	SET_TDBB(tdbb);

	const Trigger* t = nullptr;
	const bool checkTableScope = (dependency_type == obj_computed);

	while (dependencies.hasData())
	{
		Dependency dependency = dependencies.pop();

		if (!dependency.relation && !dependency.function && !dependency.procedure &&
			!dependency.name.hasData() && !dependency.number)
		{
			continue;
		}

		int dpdo_type = dependency.objType;
		Cached::Relation* relation = nullptr;
		Cached::Procedure* procedure = nullptr;
		MetaName dpdo_name;
		MetaName packageName;
		SubtypeInfo info;

		switch (dpdo_type)
		{
		case obj_relation:
			relation = dependency.relation;
			dpdo_name = relation->getName();

			fb_assert(dep_rel || !checkTableScope);

			if (checkTableScope &&
				( (dep_rel->rel_flags & (REL_temp_tran | REL_temp_conn)) !=
				  (relation->rel_flags & (REL_temp_tran | REL_temp_conn)) ))
			{
				if ( !( // master is ON COMMIT PRESERVE, detail is ON COMMIT DELETE
						(dep_rel->rel_flags & REL_temp_tran) && (relation->rel_flags & REL_temp_conn) ||
						// computed field of a view
						(dependency_type == obj_computed) && dep_rel->isView()
					   ))
				{
					string sMaster, sChild;

					make_relation_scope_name(relation->c_name(),
						relation->rel_flags, sMaster);
					make_relation_scope_name(dep_rel->c_name(),
						dep_rel->rel_flags, sChild);

					ERR_post(Arg::Gds(isc_no_meta_update) <<
							 Arg::Gds(isc_met_wrong_gtt_scope) << Arg::Str(sChild) <<
																  Arg::Str(sMaster));
				}
			}

			if (relation->isView())
				dpdo_type = obj_view;
			break;

		case obj_procedure:
			procedure = dependency.procedure;
			dpdo_name = procedure->getName().identifier;
			packageName = procedure->getName().package;
			break;

		case obj_collation:
			{
				const USHORT number = dependency.number;
				MET_get_char_coll_subtype_info(tdbb, number, &info);
				dpdo_name = info.collationName;
			}
			break;

		case obj_exception:
			{
				const SLONG number = dependency.number;
				MET_lookup_exception(tdbb, number, name, NULL);
				dpdo_name = name;
			}
			break;

		case obj_field:
			dpdo_name = dependency.name;
			break;

		case obj_generator:
			{
				// CVC: Here I'm going to track those pesky things named generators and UDFs.
				// But don't track sys gens.
				bool sysGen = false;
				const SLONG number = dependency.number;
				if (number == 0 || !MET_lookup_generator_id(tdbb, number, name, &sysGen) || sysGen)
					continue;
				dpdo_name = name;
			}
			break;

		case obj_udf:
			{
				Cached::Function* const udf = dependency.function;
				dpdo_name = udf->getName().identifier;
				packageName = udf->getName().package;
			}
			break;

		case obj_index:
			name = dependency.name;
			dpdo_name = name;
			break;
		}

		MetaName field_name;

		if (dependency.subNumber || dependency.subName.hasData())
		{
			if (dependency.subNumber)
			{
				const SSHORT fld_id = (SSHORT) dependency.subNumber;
				if (relation)
				{
					const jrd_fld* field = MET_get_field(relation->getObject(tdbb, CacheFlag::AUTOCREATE), fld_id);
					if (field)
						field_name = field->fld_name;
				}
				else if (procedure)
				{
					const Parameter* param = procedure->getObject(tdbb, CacheFlag::AUTOCREATE)->getOutputFields()[fld_id];
					// CVC: Setting the field var here didn't make sense alone,
					// so I thought the missing code was to try to extract
					// the field name that's in this case an output var from a proc.
					if (param)
						field_name = param->prm_name;
				}
			}
			else
				field_name = dependency.subName;
		}

		if (field_name.hasData())
		{
			AutoCacheRequest request(tdbb, irq_c_deps_f, IRQ_REQUESTS);
			bool found = false;
			fb_assert(dpdo_name.hasData());

			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction) X IN RDB$DEPENDENCIES WITH
				X.RDB$DEPENDENT_NAME = object_name.c_str() AND
					X.RDB$DEPENDED_ON_NAME = dpdo_name.c_str() AND
					X.RDB$DEPENDED_ON_TYPE = dpdo_type AND
					X.RDB$FIELD_NAME = field_name.c_str() AND
					X.RDB$DEPENDENT_TYPE = dependency_type
			{
				found = true;
			}
			END_FOR

			if (found)
				continue;
		}
		else
		{
			AutoCacheRequest request(tdbb, irq_c_deps, IRQ_REQUESTS);
			bool found = false;

			FOR(REQUEST_HANDLE request TRANSACTION_HANDLE transaction) X IN RDB$DEPENDENCIES WITH
				X.RDB$DEPENDENT_NAME = object_name.c_str() AND
					X.RDB$DEPENDED_ON_NAME = dpdo_name.c_str() AND
					X.RDB$DEPENDED_ON_TYPE = dpdo_type AND
					X.RDB$FIELD_NAME MISSING AND
					X.RDB$DEPENDENT_TYPE = dependency_type AND
					X.RDB$PACKAGE_NAME EQUIV NULLIF(packageName.c_str(), '')
			{
				found = true;
			}
			END_FOR

			if (found)
				continue;
		}

		AutoCacheRequest request(tdbb, irq_s_deps, IRQ_REQUESTS);

		fb_assert(dpdo_name.hasData());

		STORE(REQUEST_HANDLE request TRANSACTION_HANDLE transaction) DEP IN RDB$DEPENDENCIES
		{
			strcpy(DEP.RDB$DEPENDENT_NAME, object_name.c_str());
			DEP.RDB$DEPENDED_ON_TYPE = dpdo_type;
			strcpy(DEP.RDB$DEPENDED_ON_NAME, dpdo_name.c_str());

			if (field_name.hasData())
			{
				DEP.RDB$FIELD_NAME.NULL = FALSE;
				strcpy(DEP.RDB$FIELD_NAME, field_name.c_str());
			}
			else
				DEP.RDB$FIELD_NAME.NULL = TRUE;

			if (packageName.hasData())
			{
				DEP.RDB$PACKAGE_NAME.NULL = FALSE;
				strcpy(DEP.RDB$PACKAGE_NAME, packageName.c_str());
			}
			else
				DEP.RDB$PACKAGE_NAME.NULL = TRUE;

			DEP.RDB$DEPENDENT_TYPE = dependency_type;
		}
		END_STORE
	}
}


static bool verify_TRG_ignore_perm(thread_db* tdbb, const MetaName& trig_name)
{
/*****************************************************
 *
 *      v e r i f y _ T R G _ i g n o r e  _ p e r m
 *
 *****************************************************
 *
 * Functional description
 *      Return true if this trigger can go through without any permission
 *      checks. Currently, the only class of triggers that can go
 *      through without permission checks are
 *      (a) two system triggers (RDB$TRIGGERS_34 and RDB$TRIGGERS_35)
 *      (b) those defined for referential integrity actions such as,
 *      set null, set default, and cascade.
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();

	// See if this is a RI trigger

	AutoCacheRequest request(tdbb, irq_c_trg_perm, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		CHK IN RDB$CHECK_CONSTRAINTS CROSS
			REF IN RDB$REF_CONSTRAINTS WITH
			CHK.RDB$TRIGGER_NAME EQ trig_name.c_str() AND
			REF.RDB$CONSTRAINT_NAME = CHK.RDB$CONSTRAINT_NAME
	{
		fb_utils::exact_name_limit(REF.RDB$UPDATE_RULE, sizeof(REF.RDB$UPDATE_RULE));
		fb_utils::exact_name_limit(REF.RDB$DELETE_RULE, sizeof(REF.RDB$DELETE_RULE));

		if (!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_CASCADE) ||
			!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_NULL) ||
			!strcmp(REF.RDB$UPDATE_RULE, RI_ACTION_DEFAULT) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_CASCADE) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_NULL) ||
			!strcmp(REF.RDB$DELETE_RULE, RI_ACTION_DEFAULT))
		{
			return true;
		}

		return false;
	}
	END_FOR

	return false;
}

int MET_get_linger(thread_db* tdbb)
{
/**************************************
 *
 *	M E T _ g e t _ l i n g e r
 *
 **************************************
 *
 * Functional description
 *      Return linger value for current database
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	int rc = 0;

	AutoCacheRequest request(tdbb, irq_linger, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DAT IN RDB$DATABASE
	{
		if (!DAT.RDB$LINGER.NULL)
			rc = DAT.RDB$LINGER;
	}
	END_FOR

	return rc;
}

TriState MET_get_ss_definer(Jrd::thread_db* tdbb)
{
/**************************************
 *
 *	M E T _ s s _ d e f i n e r
 *
 **************************************
 *
 * Functional description
 *      Return sql security value for current database
 *
 **************************************/
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	TriState r;

	AutoCacheRequest request(tdbb, irq_dbb_ss_definer, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		DBB IN RDB$DATABASE
	{
		if (!DBB.RDB$SQL_SECURITY.NULL)
			r = DBB.RDB$SQL_SECURITY;
	}
	END_FOR

	return r;
}

MetadataCache::~MetadataCache()
{
/* !!!!!!!!!!!!!!!
	for (auto iter = mdc_functions.begin(); iter < mdc_functions.end(); ++iter)
		delete *iter;

	for (auto iter = mdc_procedures.begin(); iter < mdc_procedures.end(); ++iter)
		delete *iter;
 */
}

void MetadataCache::releaseGTTs(thread_db* tdbb)
{
	for (auto relation : mdc_relations)
	{
		if (relation && (relation->rel_flags & REL_temp_conn) &&
			!(relation->isDropped()))
		{
			relation->delPages(tdbb);
		}
	}
}

void MetadataCache::runDBTriggers(thread_db* tdbb, TriggerAction action)
{
	fb_assert(action == TRIGGER_CONNECT || action == TRIGGER_DISCONNECT);
	const MetaId trgKind = (action == TRIGGER_CONNECT) ? DB_TRIGGER_CONNECT : DB_TRIGGER_DISCONNECT;

	auto* element = mdc_triggers[trgKind].load(atomics::memory_order_relaxed);
	if (!element)
		return;

	auto *triggers = element->getObject(tdbb, CacheFlag::AUTOCREATE);
	if ((!triggers) || (!*triggers))
		return;

	ThreadStatusGuard temp_status(tdbb);
	jrd_tra* transaction = NULL;

	try
	{
		transaction = TRA_start(tdbb, 0, NULL);
		EXE_execute_db_triggers(tdbb, transaction, action);
		TRA_commit(tdbb, transaction, false);
		return;
	}
	catch (const Exception& /*ex*/)
	{
		Database* dbb = tdbb->getDatabase();
		if (!(dbb->dbb_flags & DBB_bugcheck) && transaction)
		{
			try
			{
				TRA_rollback(tdbb, transaction, false, false);
			}
			catch (const Exception& /*ex2*/)
			{
			}
		}
		throw;
	}
}

void MetadataCache::releaseRelations(thread_db* tdbb)
{
	// Shut down any extern relations

	for (auto relation : mdc_relations)
	{
		if (relation)
		{
			auto* ext = relation->getExtFile();
			if (ext)
				ext->release();

			// !!!!!!!!!!!
		}
	}
}

void MetadataCache::releaseLocks(thread_db* tdbb)
{
	// Go through relations and indices and release
	// all existence locks that might have been taken.

	for (auto relation : mdc_relations)
	{
		if (relation)
		{
			if (relation->rel_existence_lock)
				LCK_release(tdbb, relation->rel_existence_lock);

			if (relation->rel_partners_lock)
				LCK_release(tdbb, relation->rel_partners_lock);

			if (relation->rel_rescan_lock)
				LCK_release(tdbb, relation->rel_rescan_lock);

			relation->rel_gc_lock.forcedRelease(tdbb);

			for (auto* index : relation->rel_indices)
			{
				if (index)
					index->unlock(tdbb);
			}
		}
	}

	// Release all procedure existence locks that might have been taken

	for (auto procedure : mdc_procedures)
	{
		if (procedure)
			procedure->releaseLocks(tdbb);
	}

	// Release all function existence locks that might have been taken

	for (auto function : mdc_functions)
	{
		if (function)
			function->releaseLocks(tdbb);
	}

	// Release charset locks

	for (auto charset : mdc_charsets)
	{
		if (charset)
			charset->releaseLocks(tdbb);
	}

}

void MetadataCache::invalidateReplSet(thread_db* tdbb)
{
	for (auto relation : mdc_relations)
	{
		if (relation)
			relation->rel_repl_state.reset();
	}
}

Cached::Triggers* MetadataCache::getTriggersSet(thread_db* tdbb, MetaId triggerId)
{
	if ((triggerId & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DB)
	{
		triggerId &= ~TRIGGER_TYPE_MASK;
		return mdc_triggers[triggerId].load(atomics::memory_order_acquire);
	}

	if ((triggerId & TRIGGER_TYPE_MASK) == TRIGGER_TYPE_DDL)
		return mdc_triggers[DB_TRIGGER_DDL].load(atomics::memory_order_acquire);

	return nullptr;
}

const Triggers* MetadataCache::getTriggers(thread_db* tdbb, MetaId triggerId)
{
	auto* tset = getTriggersSet(tdbb, triggerId);
	return tset ? tset->getObject(tdbb, CacheFlag::AUTOCREATE) : nullptr;
}

void Trigger::compile(thread_db* tdbb)
{
	if (extTrigger || statement)
		return;

	const auto dbb = tdbb->getDatabase();
	const auto att = tdbb->getAttachment();

	// Allocate statement memory pool
	MemoryPool* new_pool = dbb->createPool(ALLOC_ARGS0);

	// Trigger request is not compiled yet. Lets do it now
	USHORT par_flags = (USHORT) (flags & TRG_ignore_perm) ? csb_ignore_perm : 0;

	if (type & 1)
		par_flags |= csb_pre_trigger;
	else
		par_flags |= csb_post_trigger;

	try
	{
		Jrd::ContextPoolHolder context(tdbb, new_pool);

		AutoPtr<CompilerScratch> auto_csb(FB_NEW_POOL(*new_pool) CompilerScratch(*new_pool));
		CompilerScratch* csb = auto_csb;

		csb->csb_g_flags |= par_flags;

		if (engine.isEmpty())
		{
			TraceTrigCompile trace(tdbb, this);

			if (debugInfo.hasData())
			{
				DBG_parse_debug_info((ULONG) debugInfo.getCount(), debugInfo.begin(),
									 *csb->csb_dbg_info);
			}

			PAR_blr(tdbb, getPermanent(relation), blr.begin(), (ULONG) blr.getCount(), NULL,
					&csb, &statement, (relation ? true : false), par_flags);

			trace.finish(statement, ITracePlugin::RESULT_SUCCESS);
		}
		else
		{
			dbb->dbb_extManager->makeTrigger(tdbb, csb, this, engine, entryPoint, extBody.c_str(),
				(relation ?
					(type & 1 ? IExternalTrigger::TYPE_BEFORE : IExternalTrigger::TYPE_AFTER) :
					IExternalTrigger::TYPE_DATABASE));
		}
	}
	catch (const Exception&)
	{
		if (statement)
		{
			statement->release(tdbb);
			statement = NULL;
		}
		else
			dbb->deletePool(new_pool);

		throw;
	}

	statement->triggerName = name;

	if (ssDefiner.asBool())
		statement->triggerInvoker = att->getUserId(owner);

	if (flags & TRG_ignore_perm)
		statement->flags |= Statement::FLAG_IGNORE_PERM;
}

Cached::Relation* MetadataCache::lookupRelation(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	MetadataCache* mdc = get(tdbb);
	auto rc = mdc->mdc_relations.getData(tdbb, id, flags);
	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	if (auto* rel = mdc->mdc_relations.getObject(tdbb, id, flags))
		rc = rel->rel_perm;

	return rc;
}

Cached::Relation* MetadataCache::lookupRelation(thread_db* tdbb, MetaId id)
{
	return mdc_relations.getData(tdbb, id, 0);
}

Cached::Relation* MetadataCache::lookupRelationNoChecks(MetaId id)
{
	return mdc_relations.getDataNoChecks(id);
}

Cached::Procedure* MetadataCache::lookupProcedure(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	Attachment* attachment = tdbb->getAttachment();
	MetadataCache* mdc = get(tdbb);

	// See if we already know the relation by name
	auto* rc = mdc->mdc_procedures.lookup(tdbb, [name](RoutinePermanent* proc) { return proc->name == name; }, flags);

	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	// We need to look up the procedure name in RDB$PROCEDURES
	AutoCacheRequest request(tdbb, irq_l_procedure, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		P IN RDB$PROCEDURES
		WITH P.RDB$PROCEDURE_NAME EQ name.identifier.c_str() AND
			 P.RDB$PACKAGE_NAME EQUIV NULLIF(name.package.c_str(), '')
	{
		if (auto* prc = mdc->mdc_procedures.getObject(tdbb, P.RDB$PROCEDURE_ID, flags))
			rc = prc->getPermanent();
	}
	END_FOR

	return rc;
}

Cached::Function* MetadataCache::lookupFunction(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	MetadataCache* mdc = get(tdbb);

	// See if we already know the function by name
	auto* rc = mdc->mdc_functions.lookup(tdbb, [name](RoutinePermanent* func) { return func->name == name; }, flags);

	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	auto* fun = Function::lookup(tdbb, name, flags);
	return fun ? fun->getPermanent() : nullptr;
}

Cached::Function* MetadataCache::lookupFunction(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	MetadataCache* mdc = MetadataCache::get(tdbb);
	auto* rc = mdc->mdc_functions.getData(tdbb, id, flags);
	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	if (auto* fun = mdc->mdc_functions.getObject(tdbb, id, flags))
		rc = fun->getPermanent();

	return rc;
}

Cached::Procedure* MetadataCache::lookupProcedure(thread_db* tdbb, MetaId id, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	MetadataCache* mdc = MetadataCache::get(tdbb);
	auto* rc = mdc->mdc_procedures.getData(tdbb, id, flags);
	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	if (auto* prc = mdc->mdc_procedures.getObject(tdbb, id, flags))
		rc = prc->getPermanent();

	return rc;
}

Lock* jrd_prc::makeLock(thread_db* tdbb, MemoryPool& p)
{
	return FB_NEW_RPT(p, 0) Lock(tdbb, sizeof(SLONG), LCK_prc_exist, nullptr, blockingAst);
}

int jrd_prc::blockingAst(void* ast_object)
{
/**************************************
 *
 *      b l o c k i n g _ a s t _ p r o c e d u r e
 *
 **************************************
 *
 * Functional description
 *      Someone is trying to drop a proceedure. If there
 *      are outstanding interests in the existence of
 *      the relation then just mark as blocking and return.
 *      Otherwise, mark the procedure block as questionable
 *      and release the procedure existence lock.
 *
 **************************************/
	RoutinePermanent* const procedure = static_cast<RoutinePermanent*>(ast_object);
/* !!!!!!!!!!!!!!!
	try
	{
		if (procedure->existenceLock)
		{
			Database* const dbb = procedure->existenceLock->lck_dbb;

			AsyncContextHolder tdbb(dbb, FB_FUNCTION, procedure->existenceLock);

			LCK_release(tdbb, procedure->existenceLock);
		}
		/// !!!!!!!!!!!!!!!!! 
		procedure->flags |= Routine::FLAG_OBSOLETE;
	}
	catch (const Exception&)
	{} // no-op
*/
	return 0;
}

Cached::CharSet* MetadataCache::getCharSet(thread_db* tdbb, CSetId id, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	MetadataCache* mdc = MetadataCache::get(tdbb);
	auto* rc = mdc->mdc_charsets.getData(tdbb, id, flags);
	if (rc || !(flags & CacheFlag::AUTOCREATE))
		return rc;

	if (auto* cs = mdc->mdc_charsets.getObject(tdbb, id, flags))
		rc = cs->getContainer();

	return rc;
}

MetadataCache* MetadataCache::getCache(thread_db* tdbb)
{
	return tdbb->getDatabase()->dbb_mdc;
}

int jrd_prc::objectType()
{
	return obj_procedure;
}

MetadataCache::CleanupQueue::CleanupQueue(MemoryPool& p)
	: cq_data(p)
{ }

void MetadataCache::CleanupQueue::enqueue(TraNumber traNum, ElementBase* toClean)
{
	MutexLockGuard g(cq_mutex, FB_FUNCTION);

	if (cq_data.getCount() == 0)
	{
		cq_traNum = traNum;
		fb_assert(cq_pos == 0);
	}
	cq_data.push(Stored(traNum, toClean));
}

void MetadataCache::CleanupQueue::dequeue(thread_db* tdbb, TraNumber oldest)
{
	MutexEnsureUnlock g(cq_mutex, FB_FUNCTION);

	if (!g.tryEnter())
		return;

	while (cq_pos < cq_data.getCount() && oldest > cq_data[cq_pos].t)
	{
		cq_data[cq_pos++].c->cleanup(tdbb);
	}

	if (cq_data.getCount() <= cq_pos)
	{
		fb_assert(cq_data.getCount() == cq_pos);

		cq_data.clear();
		cq_pos = 0;
		cq_traNum = MAX_TRA_NUMBER;
	}
	else
	{
		if (cq_pos > cq_data.getCount() / 2)
		{
			cq_data.removeCount(0, cq_pos);
			cq_pos = 0;
		}
		cq_traNum = cq_data[cq_pos].t;
	}
}

void MetadataCache::objectCleanup(TraNumber traNum, ElementBase* toClean)
{
	mdc_cleanup_queue.enqueue(traNum, toClean);
}

ScanResult IndexVersion::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	jrd_tra* transaction = tdbb->getTransaction() ? tdbb->getTransaction() : attachment->getSysTransaction();

	bid expression, condition;
	expression.clear();
	condition.clear();
	MetaId relId = getPermanent()->getRelation()->getId();
	bool found = false;

	Jrd::ContextPoolHolder context(tdbb, dbb->dbb_permanent);

	AutoCacheRequest handle(tdbb, irq_index_scan, IRQ_REQUESTS);
	FOR(REQUEST_HANDLE handle TRANSACTION_HANDLE transaction)
		IND IN RDB$INDICES
		CROSS REL IN RDB$RELATIONS
			OVER RDB$RELATION_NAME
		WITH IND.RDB$INDEX_ID EQ getId() + 1
			AND REL.RDB$RELATION_ID EQ relId
	{
		found = true;

		idv_name = IND.RDB$INDEX_NAME;
		idv_uniqFlag = IND.RDB$UNIQUE_FLAG;
		idv_segmentCount = IND.RDB$SEGMENT_COUNT;
		idv_type = IND.RDB$INDEX_TYPE;
		idv_foreignKey = IND.RDB$FOREIGN_KEY;

		idv_active = MetadataCache::getIndexStatus(IND.RDB$INDEX_INACTIVE.NULL, IND.RDB$INDEX_INACTIVE);

		if (!IND.RDB$EXPRESSION_BLR.NULL)
			expression = IND.RDB$EXPRESSION_BLR;
		if (!IND.RDB$CONDITION_BLR.NULL)
			condition = IND.RDB$CONDITION_BLR;
	}
	END_FOR

	if (idv_name.isEmpty())
	{
		idv_active = MET_index_inactive;
		return ScanResult::MISS;
	}
	perm->idp_name = idv_name;

	auto* relation = (expression.hasData() || condition.hasData()) ?
		MetadataCache::lookupRelation(tdbb, relId, CacheFlag::AUTOCREATE) : nullptr;
	perm->createLock(tdbb, relId, getId());
		// ?????????????? perm->createLock( caching lock

	if (expression.hasData())
	{
		AutoMemoryPool stmtPool(dbb->createPool(ALLOC_ARGS0));
		Jrd::ContextPoolHolder context(tdbb, stmtPool);

		CompilerScratch* csb = nullptr;
		Cleanup cc([csb]() {delete csb;});
		MET_parse_blob(tdbb, relation, &expression, &csb, nullptr, false, false);
		idv_expression_statement = Statement::makeValueExpression(tdbb, idv_expression, idv_expression_desc, csb, false);

		stmtPool.release();
	}

	if (condition.hasData())
	{
		AutoMemoryPool stmtPool(dbb->createPool(ALLOC_ARGS0));
		Jrd::ContextPoolHolder context(tdbb, stmtPool);

		CompilerScratch* csb = nullptr;
		Cleanup cc([csb]() {delete csb;});
		MET_parse_blob(tdbb, relation, &condition, &csb, nullptr, false, false);
		idv_condition_statement = Statement::makeBoolExpression(tdbb, idv_condition, csb, false);

		stmtPool.release();
	}

	return found ? ScanResult::COMPLETE : ScanResult::MISS;
}

IndexVersion* RelationPermanent::lookup_index(thread_db* tdbb, MetaName name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	Attachment* attachment = tdbb->getAttachment();

	// See if we already know the index by name
	auto* idp = rel_indices.lookup(tdbb,
		[tdbb, name, flags](Cached::Index* idp)->Cached::Index*
		{
			if (idp->getName() == name)
			{
				auto* idv = idp->getObject(tdbb, flags);
				if (idv && idv->getName() == name)
					return idp;
			}
			return nullptr;
		},
		flags);

	if (idp)
		return idp->getObject(tdbb, flags);
	if (!(flags & CacheFlag::AUTOCREATE))
		return nullptr;

	// We need to look up the index in RDB$INDICES
	AutoCacheRequest request(tdbb, irq_get_index_by_name, IRQ_REQUESTS);
	IndexVersion* idv = nullptr;

	FOR(REQUEST_HANDLE request)
		IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ name.c_str()
			AND IDX.RDB$RELATION_NAME EQ c_name()
	{
		if (!idv)
			idv = rel_indices.getObject(tdbb, IDX.RDB$INDEX_ID - 1, flags);
		else
			fb_assert(false);
	}
	END_FOR

	return idv;
}

Cached::Index* RelationPermanent::lookupIndex(thread_db* tdbb, MetaName name, ObjectBase::Flag flags)
{
	SET_TDBB(tdbb);

	Attachment* attachment = tdbb->getAttachment();

	// See if we already know the relation by name
	auto* idp = rel_indices.lookup(tdbb,
		[tdbb, name, flags](Cached::Index* idp)
		{
			return idp->getName() == name ? idp : nullptr;
		},
		flags);

	if (idp || !(flags & CacheFlag::AUTOCREATE))
		return idp;

	// We need to look up the index in RDB$INDICES
	AutoCacheRequest request(tdbb, irq_get_index_by_name, IRQ_REQUESTS);

	FOR(REQUEST_HANDLE request)
		IDX IN RDB$INDICES WITH IDX.RDB$INDEX_NAME EQ name.c_str()
			AND IDX.RDB$RELATION_NAME EQ c_name()
	{
		if (!idp)
		{
			if (auto* idv = rel_indices.getObject(tdbb, IDX.RDB$INDEX_ID - 1, flags))
				idp = getPermanent(idv);
		}
		else
			fb_assert(false);
	}
	END_FOR

	return idp;
}
