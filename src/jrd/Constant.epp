/*
 *	PROGRAM:		Firebird CONSTANTS implementation.
 *	MODULE:			Constant.epp
 *	DESCRIPTION:	Routine to cache and reload constants
 *
 *  The contents of this file are subject to the Initial
 *  Developer's Public License Version 1.0 (the "License");
 *  you may not use this file except in compliance with the
 *  License. You may obtain a copy of the License at
 *  http://www.ibphoenix.com/main.nfs?a=ibphoenix&page=ibp_idpl.
 *
 *  Software distributed under the License is distributed AS IS,
 *  WITHOUT WARRANTY OF ANY KIND, either express or implied.
 *  See the License for the specific language governing rights
 *  and limitations under the License.
 *
 *  The Original Code was created by Artyom Abakumov
 *  <artyom.abakumov (at) red-soft.ru> for Red Soft Corporation.
 *
 *  Copyright (c) 2025 Red Soft Corporation <info (at) red-soft.ru>
 *  and all contributors signed below.
 *
 *  All Rights Reserved.
 *  Contributor(s): ______________________________________.
 */

#include "firebird.h"
#include "../jrd/Constant.h"

#include "../jrd/tra.h"
#include "../jrd/exe_proto.h"
#include "../jrd/dfw_proto.h"
#include "../common/dsc_proto.h"
#include "../jrd/met_proto.h"
#include "../jrd/met.h"
#include "../jrd/Statement.h" // Jrd::Statement
#include "../jrd/par_proto.h" // PAR_blr

using namespace Firebird;
using namespace Jrd;

DATABASE DB = FILENAME "ODS.RDB";

//----------------------

Constant* Constant::lookup(thread_db* tdbb, MetaId id)
{
	Constant* constant = MetadataCache::get(tdbb)->getConstant(tdbb, id);
	return constant;
}

Constant* Constant::lookup(thread_db* tdbb, const QualifiedName& name, ObjectBase::Flag flags)
{
	return MetadataCache::getVersioned<Cached::Constant>(tdbb, name, flags);
}

Constant* Constant::create(thread_db* tdbb, MemoryPool& pool, Cached::Constant* perm)
{
	return FB_NEW_POOL(perm->getPool()) Constant(perm);
}


ScanResult Constant::scan(thread_db* tdbb, ObjectBase::Flag flags)
{
	Attachment* attachment = tdbb->getAttachment();
	jrd_tra* metaTransaction = attachment->getMetaTransaction(tdbb);
	Database* dbb = tdbb->getDatabase();
	MetadataCache* mdc = dbb->dbb_mdc;

	MemoryPool& pool = getPermanent()->getPool();
	bool found = false;

	//try
	{
		AutoCacheRequest request_const(tdbb, irq_l_constants, IRQ_REQUESTS);

		FOR(REQUEST_HANDLE request_const TRANSACTION_HANDLE metaTransaction)
			CONST IN RDB$CONSTANTS
			WITH CONST.RDB$CONSTANT_ID EQ this->getId()
		{
			found = true;

			getPermanent()->setName(QualifiedName(CONST.RDB$CONSTANT_NAME, CONST.RDB$SCHEMA_NAME,
				(CONST.RDB$PACKAGE_NAME.NULL ? nullptr : CONST.RDB$PACKAGE_NAME)));

			MetaName owner;
			TriState ssDefiner;
			if (!CONST.RDB$PACKAGE_NAME.NULL)
			{
				AutoCacheRequest requestHandle(tdbb, irq_l_const_pkg_class, IRQ_REQUESTS);

				FOR (REQUEST_HANDLE requestHandle)
					PKG IN RDB$PACKAGES
					CROSS SCH IN RDB$SCHEMAS
					OVER RDB$SCHEMA_NAME WITH
						PKG.RDB$SCHEMA_NAME EQ CONST.RDB$SCHEMA_NAME AND
						PKG.RDB$PACKAGE_NAME EQ CONST.RDB$PACKAGE_NAME


					owner = PKG.RDB$OWNER_NAME;

					// if (!PKG.RDB$SECURITY_CLASS.NULL)
					// {
					// 	getPermanent()->setSecurityName(QualifiedName(PKG.RDB$SECURITY_CLASS, SCH.RDB$SECURITY_CLASS));
					// }

					// SQL SECURITY of function must be the same if it's defined in package
					if (!PKG.RDB$SQL_SECURITY.NULL)
						ssDefiner = (bool) PKG.RDB$SQL_SECURITY;

				END_FOR
			}

			if (!ssDefiner.isAssigned())
			{
				ssDefiner = MET_get_ss_definer(tdbb, CONST.RDB$SCHEMA_NAME);
			}

			if (ssDefiner.asBool())
				invoker = dbb->getUserId(getPermanent()->owner);

			makeValue(tdbb, attachment, CONST.RDB$CONSTANT_BLR);
		}
		END_FOR
	}

	return found ? (this->flReload ? ScanResult::REPEAT : ScanResult::COMPLETE) : ScanResult::MISS;
}


std::optional<MetaId> Constant::getIdByName(thread_db* tdbb, const QualifiedName& name)
{
	SET_TDBB(tdbb);
	Attachment* attachment = tdbb->getAttachment();
	std::optional<MetaId> id;

	AutoCacheRequest request(tdbb, irq_l_const_id, IRQ_REQUESTS);

	FOR (REQUEST_HANDLE request)
		CONST IN RDB$CONSTANTS
		WITH CONST.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			CONST.RDB$PACKAGE_NAME EQ name.package.c_str() AND
			CONST.RDB$CONSTANT_NAME EQ name.object.c_str()
	{
		id = CONST.RDB$CONSTANT_ID;
	}
	END_FOR

	return id;
}

ScanResult Constant::reload(thread_db* tdbb, ObjectBase::Flag)
{
	Attachment* attachment = tdbb->getAttachment();
	Database* dbb = tdbb->getDatabase();
	jrd_tra* metaTransaction = attachment->getMetaTransaction(tdbb);
	AutoCacheRequest request(tdbb, irq_l_const_name, IRQ_REQUESTS);

	bool found = false;

	FOR(REQUEST_HANDLE request TRANSACTION_HANDLE metaTransaction)
		CONST IN RDB$CONSTANTS
		WITH CONST.RDB$CONSTANT_ID EQ this->getId()
	// FOR (REQUEST_HANDLE request)
	// 	CONST IN RDB$CONSTANTS
	// 	WITH CONST.RDB$SCHEMA_NAME EQ this->getName().schema.c_str() AND
	// 		CONST.RDB$PACKAGE_NAME EQ this->getName().package.c_str() AND
	// 		CONST.RDB$CONSTANT_NAME EQ this->getName().object.c_str()
	{

		if (compiling)
			return ScanResult::REPEAT;

		found = true;
		makeValue(tdbb, attachment, CONST.RDB$CONSTANT_BLR);

		// parseBlr() in makeValue could set FLAG_RELOAD again
	}
	END_FOR

	return found ? ScanResult::COMPLETE : ScanResult::MISS;
}

int Constant::objectType()
{
	return obj_package_constant;
}

void Constant::checkReload(thread_db* tdbb) const
{
	if (flReload)
		getPermanent()->reload(tdbb, 0);
}


class DropSavepoint
{
public:
	DropSavepoint(thread_db* tdbb, Jrd::jrd_tra* transaction, const QualifiedName& name) :
		m_savePoint(tdbb, transaction),
		m_tdbb(tdbb)
	{
		MetadataCache::getVersioned<Cached::Constant>(tdbb, name, CacheFlag::OLD_DROP);
	}

	DropSavepoint(thread_db* tdbb, Jrd::jrd_tra* transaction) :
		m_savePoint(tdbb, transaction),
		m_tdbb(tdbb)
	{
	}

	inline void setFound(const MetaId id) noexcept
	{
		m_id = id;
		m_found = true;
	}

	void release()
	{
		fb_assert(m_found);
		if (m_found)
			MetadataCache::erase<Cached::Constant>(m_tdbb, m_id);

		m_savePoint.release();
	}

private:
	AutoSavePoint m_savePoint;
	thread_db* m_tdbb;
	MetaId m_id{};
	bool m_found = false;
	bool m_succeed = false;
};

void Constant::drop(thread_db* tdbb, Jrd::jrd_tra* transaction, const QualifiedName& name)
{
	// Run all statements under savepoint control
	DropSavepoint savePoint(tdbb, transaction, name);

	AutoCacheRequest request(tdbb, drq_e_pkg_const_name, DYN_REQUESTS);
	FOR (REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
		CONST IN RDB$CONSTANTS
		WITH CONST.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
			CONST.RDB$PACKAGE_NAME EQ name.package.c_str() AND
			CONST.RDB$CONSTANT_NAME EQ name.object.c_str()
	{
		savePoint.setFound(CONST.RDB$CONSTANT_ID);

		ERASE CONST;
	}
	END_FOR

	savePoint.release();	// everything is ok
}

// void Constant::drop(thread_db* tdbb, Jrd::jrd_tra* transaction, const QualifiedName& name, const MetaId id)
// {
// 	// Run all statements under savepoint control
// 	DropSavepoint savePoint(tdbb, transaction, name);

// 	AutoCacheRequest request(tdbb, drq_e_pkg_const_name, DYN_REQUESTS);
// 	FOR (REQUEST_HANDLE request TRANSACTION_HANDLE transaction)
// 		CONST IN RDB$CONSTANTS
// 		WITH CONST.RDB$CONSTANT_ID EQ id
// 	{
// 		savePoint.setFound(id);

// 		ERASE CONST;
// 	}
// 	END_FOR

// 	savePoint.release();	// everything is ok
// }

void Constant::dropAllFromPackage(thread_db* tdbb, Jrd::jrd_tra* transaction, const QualifiedName& parent, bool privateFlag)
{
	AutoCacheRequest eraseConstantRequest(tdbb, drq_e_pkg_consts_by_flag, DYN_REQUESTS);
	FOR (REQUEST_HANDLE eraseConstantRequest TRANSACTION_HANDLE transaction)
			CONST IN RDB$CONSTANTS
			WITH CONST.RDB$SCHEMA_NAME EQ parent.schema.c_str() AND
				CONST.RDB$PACKAGE_NAME EQ parent.object.c_str() AND
				CONST.RDB$PRIVATE_FLAG EQ privateFlag
	{
		DropSavepoint savePoint(tdbb, transaction, QualifiedName(CONST.RDB$CONSTANT_NAME, parent.schema, parent.object));
		savePoint.setFound(CONST.RDB$CONSTANT_ID);

		ERASE CONST;

		savePoint.release();	// everything is ok
	}
	END_FOR
}

dsc Constant::getDesc(thread_db* tdbb, Jrd::jrd_tra* transaction, const QualifiedName& name)
{
	dsc desc{};
	bool succeed = false;

	FbLocalStatus status;
	AutoCacheRequest getConstantDscRequest(tdbb, drq_l_pkg_const_dsc, DYN_REQUESTS);
	FOR(REQUEST_HANDLE getConstantDscRequest TRANSACTION_HANDLE transaction)
		CONST IN RDB$CONSTANTS CROSS FLD IN RDB$FIELDS
			WITH CONST.RDB$SCHEMA_NAME EQ name.schema.c_str() AND
				CONST.RDB$PACKAGE_NAME EQ name.package.c_str() AND
				CONST.RDB$CONSTANT_NAME EQ name.object.c_str() AND
				FLD.RDB$FIELD_NAME EQ CONST.RDB$FIELD_SOURCE

		succeed = DSC_make_descriptor(&desc,
								FLD.RDB$FIELD_TYPE,
								FLD.RDB$FIELD_SCALE,
								FLD.RDB$FIELD_LENGTH,
								FLD.RDB$FIELD_SUB_TYPE,
								CSetId(FLD.RDB$CHARACTER_SET_ID),
								CollId(FLD.RDB$COLLATION_ID));
	END_FOR

	if (!succeed)
		(Arg::Gds(isc_bad_constant_type_error) << Arg::Str(name.toQuotedString())).raise();

	return desc;
}


void Constant::makeValue(thread_db* tdbb, Attachment* attachment, bid blob_id)
{
	MemoryPool* const csb_pool = attachment->att_database->createPool(ALLOC_ARGS0);
	Jrd::ContextPoolHolder context(tdbb, csb_pool);

	try
	{
		AutoPtr<CompilerScratch> csb(FB_NEW_POOL(*csb_pool) CompilerScratch(*csb_pool));

		try
		{
			Jrd::Attachment* attachment = tdbb->getAttachment();

			UCharBuffer tmp;

			{
				blb* blob = blb::open(tdbb, attachment->getSysTransaction(), &blob_id);
				ULONG length = blob->blb_length + 10;
				UCHAR* temp = tmp.getBuffer(length);
				length = blob->BLB_get_data(tdbb, temp, length);
				// blob->BLB_close(tdbb);
				tmp.resize(length);
			}

			Statement* statement = getStatement();
			flReload = false;
			CompilerScratch* csbptr = csb.get();
			PAR_blr(tdbb, &getName().schema, nullptr, tmp.begin(), (ULONG) tmp.getCount(), NULL, &csbptr, &statement, false, 0);
			setStatement(statement);

			if (csb->csb_g_flags & csb_reload)
				flReload = true;

			setImplemented(true);

			auto routineRequest = statement->makeRootRequest(tdbb);
			const dsc* temp = EVL_expr(tdbb, routineRequest, static_cast<LiteralNode*>(csb->csb_node));

			// The m_value has a string that is allocated with the tdbb pool
			// The constant cache lives longer than the tdbb pool
			// so we clear the value to prevent invalid deletions
			m_value = {};
			if (temp)
				EVL_make_value(tdbb, temp, &m_value);
			else
				m_value.vlu_desc.setNull();
		}
		catch (const Exception& ex)
		{
			StaticStatusVector temp_status;
			ex.stuffException(temp_status);

			const string name = this->getName().toQuotedString();
			(Arg::Gds(isc_bad_constant_blr_error) << Arg::Str(name)  << Arg::Str(name)
				<< Arg::StatusVector(temp_status.begin())).raise();
		}
	}
	catch (const Exception&)
	{
		attachment->att_database->deletePool(csb_pool);
		throw;
	}
}
